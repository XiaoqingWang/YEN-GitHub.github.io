<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>全栈养成计划</title>
  <subtitle>每天学点新知识~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fullstack.blog/"/>
  <updated>2017-04-19T07:16:39.000Z</updated>
  <id>http://fullstack.blog/</id>
  
  <author>
    <name>Fullstack</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我眼中的工厂模式</title>
    <link href="http://fullstack.blog/2017/04/19/%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://fullstack.blog/2017/04/19/我眼中的工厂模式/</id>
    <published>2017-04-19T07:12:54.000Z</published>
    <updated>2017-04-19T07:16:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>仅是一家之言，欢迎交流讨论、指正错误。</p>
</blockquote>
<p>本科有一门课程是设计模式，上课的时候读完了《Head First 设计模式》，这是一本很好的书，可惜当时的我不是一个好读者，囫囵吞枣看了几百页却没有吸收精华。工作以后，有了一些代码量的积累，打算补一补设计模式相关的内容。</p>
<p>这篇文章讲工厂模式，在开始分析之前，我想谈谈我对设计模式的看法。以前我之所以学不好设计模式，一方面是自己代码量不足，只能纸上谈兵，另一方面我想也和介绍设计模式的文章有关。大多数文章重点在于介绍 xxx 模式是什么，然后配上千篇一律的类图(Class Diagram) 和 Demo。好一点的文章，类图和 Demo 容易理解点，有可能还会谈谈某两个模式之间的异同。</p>
<p>但设计模式是什么？是一门必须掌握的课程，一些必须背下来的概念，然后放到实际工程里面套用的么？我不敢苟同，在我看来涉及模式其实描述了一些 Coding 的技巧。所谓的技巧，有的是能够节省冗余代码，更重要的则是开闭原则，也就是“<strong>对拓展开放，对修改关闭</strong>”，或者说得再直白点，就是方便开发者后期维护的。</p>
<p>这些技巧是有限的、反复出现的，为了便于交流和沟通，我们给这些技巧起上名字，否则每个人对这些技巧都有自己的理解，就不方便沟通了。既然是技巧，那么一定有它<strong>“巧”</strong>的一面，对比的则是原来不巧的代码。所以理解某个设计模式的实现是次要的，重点是理解它巧在哪里，因为要理解巧在哪里，所以顺便要看看如何实现。</p>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>上面这些话可能有点虚、有点绕，没关系，我举个具体例子来说。这篇文章介绍的是工厂模式，工厂模式根据“教科书”，分为三种:</p>
<ol>
<li>简单工厂模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ol>
<p>既然是工厂，那么肯定是用来生产东西的，所以有的教材或者书籍把它归类于“创建型模式”，我是坚决反对的。还有很多文章，动不动就是工厂、材料的举例，如果你以为只有创建东西，还需要材料时才用得着工厂模式，那么设计模式这门学问基本上就算失败了。</p>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>以那个经典的披萨的例子来说吧，父类叫 <code>Pizza</code>，子类有很多，什么 <code>GoodPizza</code>、<code>BadPizza</code>、<code>LargePizza</code>、<code>SmallPizza</code> 之类的随便写。</p>
<p>问题来了，这么多可能的披萨，怎么选择呢？当然是用参数来标记了。比如订披萨的时候:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Snippet 1</span></div><div class="line"><span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String type)</span></span>&#123;</div><div class="line">    Pizza pizza = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span>(type.equals(<span class="string">"g"</span>))&#123;</div><div class="line">        pizza = <span class="keyword">new</span> GoodPizza();</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">"b"</span>))&#123;</div><div class="line">        pizza = <span class="keyword">new</span> BadPizza();</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">"l"</span>))&#123;</div><div class="line">        pizza = <span class="keyword">new</span> LargePizza();</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        pizza = <span class="keyword">new</span> SmallPizza();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> pizza;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>第一段代码是原始场景，它只是实现了需求，我给它起个名字叫学校代码(School Code)，也就是那些学校里的学生写出来的，仅仅是可以运行的代码。问题很明显，一方面你不能保证只有在订披萨的时候才会创建披萨的实例对象，如果别的地方也要创建披萨对象，相同的代码就要重写一遍。另一方面这样写会导致 <code>orderPizza</code> 所在的类依赖于 <code>Pizza</code> 的四个子类，而实际上的需求仅仅是创建披萨实例而已，它的调用者并不应该依赖于具体的子类。</p>
<p>因此在订披萨的地方处理这样的字符串判断就显得不合理，解决方案也很简单，用一个专门的类来处理创建披萨的逻辑就行了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Snippet 2</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePizzaFactory</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String type)</span> </span>&#123;</div><div class="line">        Pizza pizza = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span>(type.equals(<span class="string">"g"</span>))&#123;</div><div class="line">            pizza = <span class="keyword">new</span> GoodPizza();</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">"b"</span>))&#123;</div><div class="line">            pizza = <span class="keyword">new</span> BadPizza();</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">"l"</span>))&#123;</div><div class="line">            pizza = <span class="keyword">new</span> LargePizza();</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            pizza = <span class="keyword">new</span> SmallPizza();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> pizza;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String type)</span> </span>&#123;</div><div class="line">    SimplePizzaFactory simplePizzaFactory = <span class="keyword">new</span> SimplePizzaFactory();</div><div class="line">    Pizza pizza= simplePizzaFactory.createPizza(type);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是简单工厂方法了，它说的是两个概念:</p>
<ol>
<li>一个类只做和自己相关的事，不依赖的别瞎依赖</li>
<li>有可能复用的代码抽出去，独立成类，不要到处重复</li>
</ol>
<p>这个模式和什么所谓的 <strong>工厂</strong> 一点关系都没有。假如这里调用的不是 <code>new</code> 关键字来新建对象，而是用类的静态方法，一样会有依赖问题。这种大段的细节逻辑，不管是不是创建对象，还是可以被独立出去。</p>
<p>采用了简单工厂模式以后，n 个披萨需要 n+1 个类，额外的那个是工厂类，处理创建披萨对象的具体逻辑。</p>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>我们考虑一下新增披萨种类的情况。在第二段代码的实现中，如果要新增一个子类，需要在 <code>SimplePizzaFactory</code> 中新增对子类的依赖和解析方法，也就是多一个 <code>else if</code> 的分支。如果是删除一种披萨，就需要删掉一个子类的依赖和 <code>else if</code> 分支。</p>
<p>这个操作看起来并不复杂，虽然要增改代码，但还是可以接受。不过如果子类无法修改 <code>SimplePizzaFactory</code> 代码呢？父类和工厂类有可能是基础团队在维护，而披萨子类可能是业务团队维护，不同的业务团队还有可能维护不同的子类。且不说不一定有代码的写权限，就算大家一起写，代码冲突了怎么办，忘记删除逻辑了怎么办？</p>
<p>这时候就看出问题所在了，它违反了开闭原则，也就是说并没有做到对修改关闭。怎么对修改关闭呢，这就需要借助 OOP 编程时的一个小技巧。</p>
<p>直接上代码吧，为了偷懒，我直接把 <a href="https://segmentfault.com/p/1210000009074890/read" target="_blank" rel="external">深入浅出工厂设计模式</a> 这篇文章的里的代码搬过来改改了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//snippet 3</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">APizzaStore</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String type)</span> </span>&#123;</div><div class="line">        Pizza pizza= createPizza(type);</div><div class="line">        <span class="keyword">return</span> pizza;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> Pizza <span class="title">createPizza</span><span class="params">(String type)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodPizzaStore</span> <span class="keyword">extends</span> <span class="title">APizzaStore</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function">Pizza <span class="title">createPizza</span><span class="params">(String type)</span> </span>&#123;</div><div class="line">        Pizza pizza = <span class="keyword">new</span> GoodPizza();</div><div class="line">        <span class="keyword">return</span> pizza;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>采用工厂方法模式以后，工厂不再负责具体的业务细节。它变成了一个抽象类，规定了一个<strong>抽象方法</strong> <code>createPizza</code> <strong>强迫</strong> 子类实现。同时它在 <code>orderPizza</code> 函数中调用了这个方法，但方法的实现者并不是自己。因为实际使用的并不是抽象工厂类 <code>APizzaStore</code> 而是具体的 <code>GoodPizzaStore</code>，利用<strong>多态性</strong>，实际调用的也是子类的 <code>createPizza</code> 方法。</p>
<p>所以归根结底，抽象工厂方法只是使用了一个小技巧，我称之为:</p>
<blockquote>
<p>父类定框架，子类做填充，依赖多态性</p>
</blockquote>
<p>这种技巧的好处在于将具体实现下降到各个子类中实现，父类仅仅指定这些方法何时被调用，从而不再关心有多少子类，实现了“对拓展开放、对修改关闭”。当然你也会发现方法的调用者不能再偷懒，传递字符串就能拿到合适的披萨类型了，现在</p>
<p>当然，使用工厂方法模式也有代价，对于 n 个披萨类型，现在我们需要 2n+1 个类了。其中 n 个 <code>Pizza</code> 的子类，1 个 <code>APizzaStore</code> 的抽象类负责制定流程框架，n 个 <code>APizzaStore</code> 的子类负责实现细节。</p>
<p>以还是那句话，工厂方法模式和 <strong>工厂</strong> 半毛钱关系都没有。它只是一种 OOP 下的编程技巧，在任何场景下都有可能使用。但这个技巧和语言有点关系，比如这里的例子是 Java 语言。我们知道 Java 可以把一个类标记为 <code>abstract</code>，虚拟类有一个虚拟方法。子类如果想变成具体类就必须实现这个虚拟方法。但是在 OC 中并没有虚拟类的概念，父类的空方法子类完全可以不实现，那么就无法在编译时作出这些规定，只能靠文档和 Code Review 来督促(父类方法抛错是运行时)。</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>最后聊聊抽象工厂模式，依我愚见，抽象工厂模式和 <strong>工厂</strong> 更没关系。</p>
<p>在某些极端情况下，披萨的种类可能会特别多，但并不是毫无规律的多。可能会出现可以归类的情况。比如我们考虑两个维度，一个是披萨的产地，可以是中国、美国、印度、日本等等，另一个是披萨的口味，它的数量有限，只有麻辣、微辣和不辣三种:</p>
<p><img src="http://images.bestswifter.com/1492518813.png" alt=""></p>
<p>这里画了个很简单图表，一共有 15 种披萨。我们可以用中国不辣、日本不辣、印度不辣来描述三种披萨，也可以先建立三个披萨工场，分别用来生产不辣、微辣、麻辣的披萨，然后用不辣工厂的中国披萨、日本披萨、印度披萨来描述上述三种披萨。这有点类似于数学里面提取公因数的概念。</p>
<p>假设我们建立了三个工厂，分别生产不辣、微辣、麻辣的披萨，以微辣工厂为例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//snippet 4</span></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">APizzaFactory</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ChinesePizza <span class="title">createChinesePizza</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> JapanesePizza <span class="title">createJapanesePizza</span><span class="params">()</span></span>;    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AmericanPizza <span class="title">createAmericanPizza</span><span class="params">()</span></span>;  </div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HotFactory</span> <span class="keyword">extends</span> <span class="title">APizzaFactory</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ChinesePizza <span class="title">createChinesePizza</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HotChinesePizza();  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> JapanesePizza <span class="title">createJapanesePizza</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HotJapanesePizza();  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AmericanPizza <span class="title">createAmericanPizza</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HotAmericanPizza();  </div><div class="line">    &#125;</div><div class="line">&#125;  </div><div class="line"></div><div class="line">HotFactory hotFactory = <span class="keyword">new</span> HotFactory();  </div><div class="line">ChinesePizza pizza = hotFactory.createChinesePizza();</div></pre></td></tr></table></figure>
<p>这样我们在创建披萨的时候就不用了解 15 个具体子类了，只要了解三种工厂和五个种类。换句话说我们把一个很长的一维数组(1 x 15)转化了二维数组，每个维度的长度都不大(3 x 5)。我们还可以换一个思路，比如建立五个工厂，分别表示不同国家，然后每个工厂可以生产三种不同口味的披萨。</p>
<p>那么到底是以口味为标准建立工厂，还是以国家为标准呢？我的建议是尽量减少新增工厂的可能性。比如上图中可以看到，新增口味的成本是添加五个国家披萨在这个新口味下的实现，而新增国家的成本仅仅是在已有的三个工厂中各增加一个方法。可见新增工厂(口味)比新增产品(国家)更麻烦一些。所以在上述例子中，个人建议针对不同的口味建立工厂，在实际项目中作出正确的选择应该也不会太困难。</p>
<p>考虑到披萨子类过多，而且大部分可以分类，在实际项目中为了节省代码量，我们还可以用反射的方式来动态获取类并生成实例。</p>
<p>总之，抽象工厂模式名字很玄乎，但是概念也很简单，就是用二维数组的思想来简化数量多、但可以分类的数据。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是学习设计模式的第一篇文章，从比较简单的工厂方法开始讲起。重点是忽略设计模式的表象，挖掘背后的原理。比如工厂模式就和工厂、创建对象没啥关系:</p>
<ol>
<li>简单工厂模式: 具体逻辑由具体类处理，减少不必要依赖，方便代码复用</li>
<li>工厂方法模式: 父类定框架，子类做实现，利用多态的特点实现对拓展开放，对修改关闭</li>
<li>抽象工厂模式: 借用二维数组的概念对复杂的子类做分类，简化业务逻辑。</li>
</ol>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p>本文写作过程中参考了以下两篇文章，但他们并不权威:</p>
<ol>
<li><a href="https://segmentfault.com/p/1210000009074890/read" target="_blank" rel="external">深入浅出工厂设计模式</a></li>
<li><a href="http://lh-kevin.iteye.com/blog/1981574" target="_blank" rel="external">简单工厂、工厂方法、抽象工厂、策略模式、策略与工厂的区别</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;仅是一家之言，欢迎交流讨论、指正错误。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本科有一门课程是设计模式，上课的时候读完了《Head First 设计模式》，这是一本很好的书，可惜当时的我不是一个好读者，囫囵吞枣看了几百页却没有吸收精华。工作以后
    
    </summary>
    
    
      <category term="zen" scheme="http://fullstack.blog/tags/zen/"/>
    
  </entry>
  
  <entry>
    <title>QUIC 协议概述</title>
    <link href="http://fullstack.blog/2017/04/03/QUIC-%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/"/>
    <id>http://fullstack.blog/2017/04/03/QUIC-协议概述/</id>
    <published>2017-04-03T01:28:34.000Z</published>
    <updated>2017-04-11T02:09:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>QUIC 协议是 Google 提出的一套开源协议，它基于 UDP 来实现，直接竞争对手是 TCP 协议。QUIC 协议的性能非常好，甚至在某些场景下可以实现 0-RTT 的加密通信。所以这篇文章主要讨论以下几个问题:</p>
<ol>
<li>QUIC 协议有哪些优点，如何实现 0-RTT</li>
<li>传统的 HTTP2 + SSL + TCP 协议栈有哪些缺点</li>
<li>为什么 Google 要另起炉灶，基于 UDP 去做</li>
</ol>
<p>这三个问题并不独立，所以我不会依次解答他们，我选择从一些常识入手，逐渐深入到底层细节。希望读者能够带着问题阅读并最终获得满意的答案。</p>
<h1 id="RTT"><a href="#RTT" class="headerlink" title="RTT"></a>RTT</h1><p>网络请求中一个常见的名词是 RTT(Round Trip Time)，表示客户端从发出一个请求数据，到接收到响应数据之间间隔的时间。</p>
<p><img src="http://images.bestswifter.com/RTT.png" alt="RTT"></p>
<p>RTT 可以理解成由两部分组成，一部分受到物理条件的限制，比如间隔距离除以信号传递速度，以及包大小除以带宽。另一部分则是客户端、服务器以及沿途各路由器对包的处理解析时间。一般情况下，RTT 大约在几十毫秒左右，网络很好的情况下可以达到个位数，恶劣网络环境下达到几百毫秒也有可能。</p>
<p>根据阮一峰的 <a href="http://www.ruanyifeng.com/blog/2014/09/ssl-latency.html" target="_blank" rel="external">SSL延迟有多大？</a> 一文中做的计算，用户访问支付宝时，一个 RTT 大约需要 22ms，算上 SSL 握手的三个 RTT 则大约消耗了 64ms。</p>
<p>可见网络请求时间绝对不是简单的数据量除以网速这么简单， RTT 是网络请求耗时中不可忽略的一部分，不仅仅是握手阶段需要三个 RTT，在实际网络请求中，还有可能因为丢包等问题而额外增加 RTT。因此任何一个能减少 RTT 的技术都值得认真考虑，因为他们<strong>真的能够显著降低</strong>网络请求耗时。</p>
<h2 id="QUIC-协议概述"><a href="#QUIC-协议概述" class="headerlink" title="QUIC 协议概述"></a>QUIC 协议概述</h2><p>下面进入正题，本文的主角，QUIC 协议主要具备以下优点:</p>
<ol>
<li>多路复用，避免队头阻塞</li>
<li>减少 RTT，请求更快速</li>
<li>快速迭代，广泛支持</li>
</ol>
<h1 id="多路复用，避免队头阻塞"><a href="#多路复用，避免队头阻塞" class="headerlink" title="多路复用，避免队头阻塞"></a>多路复用，避免队头阻塞</h1><p>这句话说起来很容易，但理解起来并不那么显然，要想理解 QUIC 协议到底做了什么以及这么做的必要性，我想还是从最基础的 HTTP 1.0 聊起比较合适。</p>
<h2 id="Pipiline"><a href="#Pipiline" class="headerlink" title="Pipiline"></a>Pipiline</h2><p>根据谷歌的调查， 现在请求一个网页，平均涉及到 80 个资源，30 多个域名。考虑最原始的情况，每请求一个资源都需要建立一次 TCP 请求，显然不可接受。HTTP 协议规定了一个字段 <code>Connection</code>，不过默认的值是 <code>close</code>，也就是不开启。</p>
<p>早在 1999 年提出的 <a href="https://www.ietf.org/rfc/rfc2616.txt" target="_blank" rel="external">HTTP 1.1 协议</a> 中就把 <code>Connection</code> 的默认值改成了<code>Keep-Alive</code>，这样同一个域名下的多个 HTTP 请求就可以复用同一个 TCP 连接。这种做法被称为 HTTP Pipeline，优点是显著的减少了建立连接的次数，也就是大幅度减少了 RTT。以上面的数据为例，如果 80 个资源都要走一次 HTTP 1.0，那么需要建立 80 个 TCP 连接，握手 80 次，也就是 80 个 RTT。如果采用了 HTTP 1.1 的 Pipeline，只需要建立 30 个 TCP 连接，也就是 30 个 RTT，提高了 <strong>62.5%</strong> 的效率。</p>
<p>Pipeline 解决了 TCP 连接浪费的问题，但它自己还存在一些不足之处，也就是所有管道模型都难以避免的队头阻塞问题。</p>
<h2 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h2><p>我们再举个简单而且直观的例子，假设加载一个 HTML 一共要请求 10 个资源，那么请求的总时间是每一个资源请求时间的总和。最直观的体验就是，网速越快请求时间越短。然而如果某一个资源的请求被阻塞了(比如 SQL 语句执行非常慢)。但对于客户端来说所有后续的请求都会因此而被阻塞。</p>
<p><img src="http://images.bestswifter.com/HOC.png" alt="HOC"></p>
<p>队头阻塞(Head of line blocking，下文简称 HOC)说的是当有多个串行请求执行时，如果第一个请求不执行完，后续的请求也无法执行。比如上图中，如果第四个资源的传输花了很久，后面的资源都得等着，平白浪费了很多时间，带宽资源没有得到充分利用。</p>
<p>因此，HTTP 协议允许客户端发起多个并行请求，比如在笔者的机器上最多支持六个并发请求。并发请求主要是用于解决 HOC 问题，当有三个并发请求时，情况会变成这样:</p>
<p><img src="http://images.bestswifter.com/Multi.png" alt="Multi Request"></p>
<p>可见虽然第四个资源的请求被阻塞了，但是其他的资源请求并不一定会被阻塞，这样总的来说网络的平均利用率得到了提升。</p>
<p>支持并发请求是解决解决 HOC 问题的一种方案，这句话没有错，但是我们要理解到: “并发请求并非是直接解决了 HOC 的问题，而是尽可能减少 HOC 造成的影响”，以上图为例，HOC 的问题依然存在，只是不会太浪费带宽而已。有读者可能会好奇，为什么不多搞几个并发的 HTTP 请求呢？刚刚说过笔者的电脑最多支持 6 个并发请求，谷歌曾经做过实验，把 6 改成 10，然后尝试访问了三千多个网页，发现平均访问时间竟然还增加了 5% 左右。这是因为一次请求涉及的域名有限，再多的并发 HTTP 请求并不能显著提高带宽利用率，反而会消耗性能。</p>
<h2 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h2><p>有没有办法解决队头阻塞呢，答案是肯定的。SPDY 协议的做法很值得借鉴，它采用了多路复用(Multiplexing) 技术，允许多个 HTTP 请求共享同一个 TCP 连接。我们假设每个资源被分为多个包传递，在 HTTP 1.1 中只有前面一个资源的所有数据包传输完毕后后面资源的包才能开始传递(HOC 问题)，而 SPDY 并不这么要求，大家可以一起传输。</p>
<p><img src="http://images.bestswifter.com/1491491570.png" alt=""></p>
<p>这么做的代价是数据会略微有一些冗余，每一个资源的数据包都要带上标记，用来指明自己属于哪个资源，这样客户端最后才能把他们正确的拼接起来。不同的标记可以理解为图中不同的颜色，每一个小方格可以理解为资源的某一个包。</p>
<p>有些读者对 SPDY 协议可能不太了解，其实把它当做 HTTP2 的前身和试验品就好。当然 HTTP2.0 的好处远远不止这些，比如我们可以很容易的基于 HTTP2.0 实现长连接，而以往的选择要么是用更底层的 TCP，要么是使用与 HTTP 同级的 Web Socket 协议。现在 HTTP 协议直接支持了长连接，对开发者而言确实是一大利好。考虑到本篇文章主要是讨论 QUIC 协议相关，就不对 HTTP 2.0 做详细分析了。</p>
<h2 id="茶歇小结"><a href="#茶歇小结" class="headerlink" title="茶歇小结"></a>茶歇小结</h2><p>刚刚聊到了三个技术名词，Pipeline、并发请求和多路复用，千万不要被绕晕了。</p>
<p>Pipeline 是为了减少不必要的 TCP 连接，但依然存在队头阻塞(HOC)的缺点，一种解决思路是利用并发连接减少某一个 HOC 的影响，另一个是共享(<strong>注意与复用的区别</strong>) TCP 连接，直接避免 HOC 问题的发生。</p>
<h2 id="TCP-窗口"><a href="#TCP-窗口" class="headerlink" title="TCP 窗口"></a>TCP 窗口</h2><p>是不是觉得 SPDY 的多路复用已经够厉害了，解决了队头阻塞问题？很遗憾的是，并没有，而且我可以很肯定的说，只要你还在用 TCP 链接，HOC 就是逃不掉的噩梦，不信我们来看看 TCP 的实现细节。</p>
<p>我们知道 TCP 协议会保证数据的可达性，如果发生了丢包或者错包，数据就会被重传。于是问题来了，如果一个包丢了，那么后面的包就得停下来等这个包重新传输，也就是发生了队头阻塞。当然 TCP 协议的设计者们也不傻，他们发明了滑动窗口的概念:</p>
<p><img src="http://images.bestswifter.com/network/tcp-window.png" alt="TCP 窗口"></p>
<p>这样的好处是在第一个数据包(1-1000) 发出后，不必等到 ACK 返回就可以立刻发送第二个数据包。可以看出图中的 TCP 窗口大小是 4，所以第四个包发送后就会开始等待，直到第一个包的 ACK 返回。这样窗口可以向后滑动一位，第五个包被发送。</p>
<p>如果第一、二、三个的包都丢失了也没有关系，当发送方收到第四个包时，它可以确信一定是前三个 ACK 丢了而不是数据包丢了，否则不会收到 4001 的 ACK，所以发送方可以大胆的把窗口向后滑动四位。</p>
<p>滑动窗口的概念大幅度提高了 TCP 传输数据时抗干扰的能力，一般丢失一两个 ACK 根本没关系。但如果是发送的包丢失，或者出错，窗口就无法向前滑动，出现了队头阻塞的现象。</p>
<h2 id="QUIC-多路复用与纠错"><a href="#QUIC-多路复用与纠错" class="headerlink" title="QUIC 多路复用与纠错"></a>QUIC 多路复用与纠错</h2><p>所以说 HOC 不仅仅在 HTTP 层存在，在 TCP 层也存在，这也正是 QUIC 协议要解决的问题。回顾 SPDY 是如何解决 HOC 的，没错，多路复用(Multiplex)。QUIC 协议也采用了多路复用技术。</p>
<p><img src="http://images.bestswifter.com/1491206971.png" alt="QUIC 多路复用"></p>
<p>QUIC 协议基于 UDP 实现，我们知道 UDP 协议只负责发送数据，并不保证数据可达性。这一方面为 QUIC  的多路复用提供了基础，另一方面也要求 QUIC 协议自己保证数据可达性。</p>
<p>SPDY 为各个数据包做好标记，指明他们属于哪个 HTTP 请求，至于这些包能不能到达客户端，SPDY 并不关心，因为数据可达性由 TCP 协议保证。既然客户端一定能收到包，那就只要排序、拼接就行了。QUIC 协议采用了多路复用度思想，但同时还得自己保证数据的可达性。</p>
<p>TCP 协议的丢包重传并不是一个好想法，因为一旦有了前后顺序，队头阻塞问题将不可避免。而无序的数据发送给接受者以后，如何保证不丢包，不错包呢？这看起来是个不可能完成的任务，不过如果把要求降低成:“最多丢一个包，或者错一个包”，事情就简单多了，操作系统中有一种存储方式叫 RAID 5，采用的是异或运算加上数据冗余的方式来保证前向纠错(FEC: Forward Error Correcting)。</p>
<p>我们知道异或运算的规则是，<code>0 ^ 1 = 1</code>、<code>1 ^ 1 = 0</code>，也就是相同数字异或成 1，不同数字异或成 0。对两个数字做异或运算，其实就是将他们转成二进制后按位做异或，因此对于任何数字 a，都有:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a ^ a = <span class="number">0</span></div><div class="line">a ^ <span class="number">0</span> = a</div></pre></td></tr></table></figure>
<p>同时很容易证明异或运算满足交换律和结合律，我们假设有下面这个等式:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A1 ^ A2 ^ A3 ^ ... ^ An = T</div></pre></td></tr></table></figure>
<p>如果想让等式的左边只留下一个一个元素，只要在等号两边做 n-1 次异或就可以了:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(A1 ^ A1) ^ A2 ^ A3 ^ ... ^ An = T ^ A1</div><div class="line"><span class="comment">// 所以</span></div><div class="line">A2 ^ A3 ^ ... ^ An = T ^ A1</div><div class="line"><span class="comment">// 所以</span></div><div class="line">A3 ^ ... ^ An = T ^ A1 ^ A2</div><div class="line"><span class="comment">// 所以 ......</span></div><div class="line">Ai = T ^ A1 ^ A2 ^ ... Ai<span class="number">-1</span> ^ Ai+<span class="number">1</span> ^ Ai+<span class="number">2</span> ^ ... ^ An</div></pre></td></tr></table></figure>
<p>换句话说，A1 到 An 和 T 这总共 n+1 个元素中，不管是任何一个元素缺失，都可以从另外 n 个元素推导出来。如果把 A1、A2 一直到 An 想象成要发送的数据，T 想象成冗余数据，那么除了丢包重传，我们还可以采用冗余数据包的形式来保证数据准确性。</p>
<p>举个例子，假设有 5 个数据包要发送，我可以额外发送一个包(上面例子中的 T)，它的值是前五个包的异或结果。这样不管是前五个包中丢失了任何一个，或者某个包数据有错(可以当成丢包来处理)，都可以用另外四个包和这个冗余的包 T 进行异或运算，从而恢复出来。</p>
<p>当然要注意的是，这种方案仅仅在只发生一个错包或丢包时有效，如果丢失两个包就无能为力了(这也就是为什么只发一个冗余包就够的原因)。因此数据包和冗余包之间的比值需要精心设计，如果比值过高，很容易出现丢两个包的情况，如果比值过低，又会导致冗余度太高，需要设计者根据概率计算结果进行权衡。</p>
<p>利用冗余数据的思想，QUIC 协议基本上避免了重发数据的情况，这种利用已有数据就能进行错误恢复的技术叫做前向恢复(FEC: Fowrard Error Correcting)。当然 QUIC 协议还是支持重传的，比如某些非常重要的数据或者丢失两个包的情况。</p>
<h1 id="更少的-RTT"><a href="#更少的-RTT" class="headerlink" title="更少的 RTT"></a>更少的 RTT</h1><p>我们考虑一次 HTTPS 请求，它的基本流程是三次 TCP 握手外加四次 SSL/TLS 握手，从图中可以看到这需要三个 RTT:</p>
<p><img src="http://images.bestswifter.com/3-RTT.png" alt="3 RTT"></p>
<p>对于 HTTP 2.0 来说，本来需要一个额外的 RTT 来进行协商，判断客户端与服务器是不是都支持 HTTP 2.0，不过好在它可以和 SSL 握手的请求合并。这也就是为什么大多数主流浏览器(比如 Chrome、Firefox) 仅支持 HTTPS 2.0 而不单独支持 HTTP 2.0 的原因，毕竟 HTTP 2.0 需要一个额外的 RTT，HTTPS 2.0 需要两个额外的 RTT，仅仅是增加一个 RTT 就能获得数据安全性，还是很划算的。</p>
<h2 id="SSL-握手优化"><a href="#SSL-握手优化" class="headerlink" title="SSL 握手优化"></a>SSL 握手优化</h2><p>有关 HTTPS 的详细解释可以参考我之前的文章: <a href="http://www.jianshu.com/p/072a657337ae" target="_blank" rel="external">九个问题从入门到熟悉HTTPS</a>，这里我们简单复习一下 SSL 握手的大致流程:</p>
<ol>
<li>客户端发送第一个握手，包含一个随机数，以及对协议的支持情况(版本、加密方法、压缩方法等)</li>
<li>服务器返回证书，以及服务端生成随机数</li>
<li>客户端校验证书，生成一个新的随机数，用证书中的公钥加密后发给服务端</li>
<li>服务端确认消息，双方根据上述三个随机数生成后续会话的公钥</li>
</ol>
<p>由于需要确认证书，生成多个随机数来保证安全，握手阶段的两个 RTT 很难节省。不过之前我们见过 HTTP 的 Pipeline 技术可以复用 TCP 连接，那么按照类似的思想，SSL 连接也可以被恢复。思考一下为什么 SSL 要设计这么复杂的握手机制，它本质上是为了保证对称秘钥的安全传输，所以 SSL 会话恢复主要考虑的也是如何恢复对称秘钥。</p>
<p>一个常用的方案是采用 Session Ticket，实现起来很容易: 一旦 SSL 会话建立起来，服务端把会话的基本信息，比如对称秘钥、加密方法等信息加密后发给客户端，客户端可以缓存下来这个 Session Ticket。需要恢复 SSL 会话时直接把它发回给服务端校验即可，这样可以在 SSL 层减少一个 RTT。</p>
<h2 id="TCP-快速打开"><a href="#TCP-快速打开" class="headerlink" title="TCP 快速打开"></a>TCP 快速打开</h2><p>聊完了 SSL 层，下面说说 TCP 的优化方案。我们都知道 TCP 的三次握手需要花费一个 RTT，有没有可能做到 0-RTT 呢？比如我们在握手的时候就带上要传递的数据。</p>
<p>实际上 TCP 协议已经规定了这种情况的处理方式，即客户端可以在发送第一个 SYN 握手包时携带数据，但是 TCP 协议的实现者<strong>绝对不允许</strong>(原文: MUST NOT) 把这个数据包上传给应用层。这主要是为了防止 TCP 泛洪攻击。</p>
<p>TCP 泛洪攻击是指攻击者利用多台机器发送 SYN 请求从而耗尽服务器的 backlog 队列，backlog 队列维护的是那些接受了 SYN 请求但还没有正式开始会话的连接。这样做的好处是服务器不会过早的分配端口、建立连接。<a href="https://tools.ietf.org/html/rfc4987" target="_blank" rel="external">RFC 4987</a> 详细的描述了各种防止 TCP 泛洪攻击的方法，包括尽早释放 SYN，增加队列长度等等。</p>
<p>如果 SYN 握手的包能被传输到应用层，那么现有的防护措施都无法防御泛洪攻击，而且服务端也会因为这些攻击而耗尽内存和 CPU。所以人们设计了 TFO (TCP Fast Open)，这是对 TCP 的拓展，不仅可以在发送 SYN 时携带数据，还可以保证安全性。</p>
<p>TFO 设计了一个 cookie，它在第一次握手时由 server 生成，cookie 主要是用来标识客户端的身份，以及保存上次会话的配置信息。因此在后续重新建立 TCP 连接时，客户端会携带 SYN + Cookie + 请求数据，然后不等 ACK 返回就直接开始发送数据。</p>
<p><img src="http://images.bestswifter.com/1491536313.png" alt="TFO 工作示意图"></p>
<p>服务端收到 SYN 后会验证 cookie 是否有效，如果无效则会退回到三次握手的步骤，如下图所示:</p>
<p><img src="http://images.bestswifter.com/1491536652.png" alt="回退到普通三次握手"></p>
<p>同时，为了安全起见，服务端为每个端口记录了一个值 <code>PendingFastOpenRequests</code>，用来表示有多少请求利用了 TFO，如果超过预设上限就不再接受。</p>
<p>关于 TFO 的优化，可以总结出三点内容:</p>
<ol>
<li>TFO 设计的 cookie 思想和 SSL 恢复握手时的 Session Ticket 很像，都是由服务端生成一段 cookie 交给客户端保存，从而避免后续的握手，有利于快速恢复。</li>
<li>第一次请求绝对不会触发 TFO，因为服务器会在接收到 SYN 请求后把 cookie 和 ACK 一起返回。后续客户端如果要重新连接，才有可能使用这个 cookie 进行 TFO</li>
<li>TFO 并不考虑在 TCP 层过滤重复请求，以前也有类似的提案想要做过滤，但因为无法保证安全性而被拒绝。所以 TFO 仅仅是避免了泛洪攻击(类似于 backlog)，但客户端接收到的，和 SYN 包一起发来的数据，依然有可能重复。不过也只有可能是 SYN 数据重复，所以 TFO 并不处理这种情况，要求服务端程序自行解决。这也就是说，不仅仅要操作系统的支持，更要求应用程序(比如 MySQL) 也支持 TFO。</li>
</ol>
<h2 id="0-RTT"><a href="#0-RTT" class="headerlink" title="0-RTT"></a>0-RTT</h2><p>TFO 使得 TCP 协议有可能变成 0-RTT，核心思想和 Session Ticket 的概念类似: 将当前会话的上下文缓存在客户端。如果以后需要恢复对话，只需要将缓存发给服务器校验，而不必花费一个 RTT 去等待。</p>
<p>结合 TFO 和 Session Ticket 技术，一个本来需要花费 3 个 RTT 才能完成的请求可以被优化到一个 RTT。如果使用 QUIC 协议，我们甚至可以更进一步，将 Session Ticket 也放到 TFO 中一起发送，这样就实现了 0-RTT 的对话恢复。感兴趣的读者可以阅读: <a href="https://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;mid=2651113095&amp;idx=1&amp;sn=0f7beafe5f48b4fdcde5465373044eab" target="_blank" rel="external">Facebook App对TLS的魔改造：实现0-RTT</a></p>
<h1 id="Why-QUIC"><a href="#Why-QUIC" class="headerlink" title="Why QUIC"></a>Why QUIC</h1><p>从以上分析可以发现，HTTP2 和 SSL 可以说已经进行了大量的优化，可以提升的空间非常小。而 TCP 存在诸多不足之处，一方面它设计较早，而且主要目的是设计一种通用、可靠的传输协议，并非专门为网页或者 App 而设计，另一方面对 TCP 的改进要比对 SSL 和 HTTP 的改进麻烦的多，因为 TCP 是由各个操作系统实现，就以 TFO 为例吧，它在新版本的 Linux 内核中被实现，但想等到它普及开来就不知道要到猴年马月了，有兴趣的读者可以参考参考现在 Windows XP 系统的市场占有率。</p>
<p>反观 HTTP 和 SSL，虽然早期 HTTP 1.0 的问题更多，但是经过 1.1、SPDY、2.0 等版本的更迭，已经非常优秀了。其中的根本原因还是在于 HTTP  和 SSL 位于应用层，优化升级比较容易实现，所以经过长年累月的优化升级，现在大部分瓶颈都集中于 TCP 层。但 TCP 不仅优化点较多，而且还不容易更新。那么能不能在传输层搞一个和 TCP、UDP 类似的协议呢？答案也是否定的，其实曾经有一个 SCTP 协议打算进行一系列优化，但并没有被广泛接受。这是因为数据在传输的过程中需要经过各个路由器，这些设备只能识别并解析 TCP 和 UDP 协议的数据包，无法解析新的协议。所以 SCTP 也只能用于内网的实验环境中。</p>
<p>TCP 要改进，但不方便改，新增一个协议又不被已有的设备支持，看起来唯一的方案就是使用 UDP 了。虽然 UDP 协议不保证数据可达性，但这也是 UDP 的优点所在，它天然支持 0-RTT 的通信，所以一个比较新颖激进的想法就冒出来了:</p>
<p><strong>采用 UDP 作为底层协议，在 UDP 之上实现数据可达性</strong></p>
<p>目前，QUIC 协议内置在 Chrome 浏览器中，每次更新只需要升级浏览器即可，在 2014 年前就已经迭代了 13 个版本。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后，作为总结，我简单回答一下文章开头的几个问题:</p>
<ol>
<li>QUIC 协议有哪些优点，如何实现 0-RTT？<ol>
<li>QUIC 协议在传输层就支持多路复用，避免了队头阻塞问题。</li>
<li>QUIC 协议基于 UDP，更自由更高效</li>
<li>QUIC 协议借鉴了 TFO 的思想，支持会话上下文缓存，方便恢复，具备实现 0-RTT 的可能</li>
</ol>
</li>
<li>传统的 HTTP2 + SSL + TCP 协议栈有哪些缺点？<ol>
<li>SSL 的会话恢复依然需要一个 RTT，而且难以合并到 TCP 层</li>
<li>TCP 的滑动窗口存在队头阻塞问题</li>
<li>TCP 的重传纠错会浪费一个 RTT</li>
</ol>
</li>
<li>为什么 Google 要另起炉灶，基于 UDP 去做？<ol>
<li>TCP 由操作系统实现，很难更新</li>
<li>UDP 非常高效，几乎没有性能负担</li>
<li>将 QUIC 嵌入到 Chrome 中可以方便后续的升级迭代</li>
</ol>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h1><ol>
<li><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html?utm_source=tuicool" target="_blank" rel="external">图解SSL/TLS协议</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="external">SSL/TLS协议运行机制的概述</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;mid=2651113095&amp;idx=1&amp;sn=0f7beafe5f48b4fdcde5465373044eab" target="_blank" rel="external">Facebook App对TLS的魔改造：实现0-RTT</a></li>
<li><a href="https://www.youtube.com/watch?v=hQZ-0mXFmk8" target="_blank" rel="external">视频: QUIC: next generation multiplexed transport over UDP</a></li>
<li><a href="https://docs.google.com/document/d/1WJvyZflAO2pq77yOLbp9NsGjC1CHetAXV8I0fQe-B_U/edit#heading=h.o9jvitkc5d2g" target="_blank" rel="external">官方文档: QUIC Wire Layout Specification</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;QUIC 协议是 Google 提出的一套开源协议，它基于 UDP 来实现，直接竞争对手是 TCP 协议。QUIC 协议的性能非常好，甚至在某些场景下可以实现 0-RTT 的加密通信。所以这篇文章主要讨论以下几个问题:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;QUIC 协议有哪些优点，如
    
    </summary>
    
    
      <category term="前端" scheme="http://fullstack.blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="网络" scheme="http://fullstack.blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>九个问题从入门到熟悉HTTPS </title>
    <link href="http://fullstack.blog/2017/03/12/%E4%B9%9D%E4%B8%AA%E9%97%AE%E9%A2%98%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%86%9F%E6%82%89HTTPS/"/>
    <id>http://fullstack.blog/2017/03/12/九个问题从入门到熟悉HTTPS/</id>
    <published>2017-03-12T10:23:56.000Z</published>
    <updated>2017-03-12T11:01:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>女朋友也是软件工程专业，因为快要毕业了，最近一边做毕设一边学习编程。前两天她问我 HTTPS 的问题，本来想直接扔一篇网上的教程给她。后来想了一下，那些文章大多直接介绍概念， 对新手不太友好，于是我干脆亲自给她解释一下，顺便整理了一份问答录。</p>
<h3 id="Q1-什么是-HTTPS？"><a href="#Q1-什么是-HTTPS？" class="headerlink" title="Q1: 什么是 HTTPS？"></a>Q1: 什么是 HTTPS？</h3><h3 id="BS-HTTPS-是安全的-HTTP"><a href="#BS-HTTPS-是安全的-HTTP" class="headerlink" title="BS: HTTPS 是安全的 HTTP"></a>BS: HTTPS 是安全的 HTTP</h3><p>HTTP 协议中的内容都是明文传输，HTTPS 的目的是将这些内容加密，确保信息传输安全。最后一个字母 S 指的是 SSL/TLS 协议，它位于 HTTP 协议与 TCP/IP 协议中间。</p>
<h3 id="Q2-你说的信息传输安全是什么意思"><a href="#Q2-你说的信息传输安全是什么意思" class="headerlink" title="Q2: 你说的信息传输安全是什么意思"></a>Q2: 你说的信息传输安全是什么意思</h3><h3 id="BS-信息传输的安全有三个方面"><a href="#BS-信息传输的安全有三个方面" class="headerlink" title="BS: 信息传输的安全有三个方面:"></a>BS: 信息传输的安全有三个方面:</h3><ol>
<li>客户端和服务器直接的通信只有自己能看懂，即使第三方拿到数据也看不懂这些信息的真实含义。</li>
<li>第三方虽然看不懂数据，但可以 XJB 改，因此客户端和服务器必须有能力判断数据是否被修改过。</li>
<li>客户端必须避免中间人攻击，即除了真正的服务器，任何第三方都无法冒充服务器。</li>
</ol>
<p>很遗憾的是，目前的 HTTP 协议还不满足上述三条要求中的任何一条。</p>
<h3 id="Q3-这么多要求，一个一个去满足是不是很累？"><a href="#Q3-这么多要求，一个一个去满足是不是很累？" class="headerlink" title="Q3: 这么多要求，一个一个去满足是不是很累？"></a>Q3: 这么多要求，一个一个去满足是不是很累？</h3><h3 id="BS-不累，第三个要求可以不用管"><a href="#BS-不累，第三个要求可以不用管" class="headerlink" title="BS: 不累，第三个要求可以不用管"></a>BS: 不累，第三个要求可以不用管</h3><p>是的，我没开玩笑，你可以暂时别管第三个要求，因为它实际上隶属于第一个需求。我们都知道加密需要密码，密码不是天下掉下来，也得需要双方经过通信才能协商出来。所以一个设计良好的加密机制必然会防止第三者的干扰和伪造。等搞明白了加密的具体原理，我们自然可以检验是否满足:“任何第三者无法冒充服务器”这一要求。</p>
<h3 id="Q4-那怎么加密信息呢"><a href="#Q4-那怎么加密信息呢" class="headerlink" title="Q4: 那怎么加密信息呢"></a>Q4: 那怎么加密信息呢</h3><h3 id="BS-使用对称加密技术"><a href="#BS-使用对称加密技术" class="headerlink" title="BS: 使用对称加密技术"></a>BS: 使用对称加密技术</h3><p>对称加密可以理解为对原始数据的可逆变换。比如 <code>Hello</code> 可以变换成 <code>Ifmmp</code>，规则就是每个字母变成它在字母表上的后一个字母，这里的秘钥就是 <code>1</code>，另一方拿到 <code>Ifmmp</code> 就可以还原成原来的信息 <code>Hello</code> 了。</p>
<p>引入对称加密后，HTTPS 的握手流程就会多了两步，用来传递对称加密的秘钥:</p>
<ol>
<li>客户端: 你好，我需要发起一个 HTTPS 请求</li>
<li>服务器: 好的，你的秘钥是 <code>1</code>。</li>
</ol>
<p>提到了对称加密，那么自然还有非对称加密。它的思想很简单，计算两个质数的乘积很容易，但反过来分解成两个质数的乘积就很难，要经过极为复杂的运算。非对称加密有两个秘钥，一个是公钥，一个是私钥。公钥加密的内容只有私钥可以解密，私钥加密的内容只有公钥可以解密。一般我们把服务器自己留着，不对外公布的密钥称为<strong>私钥</strong>，所有人都可以获取的称为<strong>公钥</strong>。</p>
<p>使用对称加密一般要比非对称加密快得多，对服务器的运算压力也小得多。</p>
<h3 id="Q5-对称秘钥如何传输"><a href="#Q5-对称秘钥如何传输" class="headerlink" title="Q5: 对称秘钥如何传输"></a>Q5: 对称秘钥如何传输</h3><p>服务器直接返回明文的对称加密密钥是不是不安全。如果有监听者拿到这个密钥，不就知道客户端和服务器后续的通信内容了么？</p>
<h3 id="BS-利用非对称加密"><a href="#BS-利用非对称加密" class="headerlink" title="BS: 利用非对称加密"></a>BS: 利用非对称加密</h3><p>是这样，所以不能明文传递对称秘钥，而且也不能用一个新的对称加密算法来加密原来的对称秘钥，否则新的对称秘钥同样无法传输，这就是鸡生蛋、蛋生鸡的悖论。</p>
<p>这里我们引入非对称加密的方式，非对称加密的特性决定了服务器用私钥加密的内容并不是<strong>真正的加密</strong>，因为公钥所有人都有，所以服务器的密文能被所有人解析。但私钥只掌握在服务器手上，这就带来了两个巨大的优势:</p>
<ol>
<li>服务器下发的内容不可能被伪造，因为别人都没有私钥，所以无法加密。强行加密的后果是客户端用公钥无法解开。</li>
<li>任何人用公钥加密的内容都是绝对安全的，因为私钥只有服务器有，也就是只有真正的服务器可以看到被加密的原文。</li>
</ol>
<p>所以传输对称秘钥的问题就迎刃而解了: 秘钥不是由服务器下发，而是由客户端生成并且主动告诉服务器。</p>
<p>所以当引入非对称加密后，HTTPS 的握手流程依然是两步，不过细节略有变化:</p>
<ol>
<li>客户端: 你好，我需要发起一个 HTTPS 请求，这是我的 (用公钥加密后的) 秘钥。</li>
<li>服务器: 好的，我知道你的秘钥了，后续就用它传输。</li>
</ol>
<h3 id="Q5-那公钥怎么传输"><a href="#Q5-那公钥怎么传输" class="headerlink" title="Q5: 那公钥怎么传输"></a>Q5: 那公钥怎么传输</h3><p>你好像还是没有解决鸡生蛋，蛋生鸡的问题。你说客户端发送请求时要用公钥加密对称秘钥，那公钥怎么传输呢？</p>
<h3 id="BS-对公钥加密就行了。。。"><a href="#BS-对公钥加密就行了。。。" class="headerlink" title="BS: 对公钥加密就行了。。。"></a>BS: 对公钥加密就行了。。。</h3><p>每一个使用 HTTPS 的服务器都必须去专门的证书机构注册一个证书，证书中存储了用权威机构私钥加密的公钥。这样客户端用权威机构的公钥解密就可以了。</p>
<p>现在 HTTPS 协议的握手阶段变成了四步:</p>
<ol>
<li>客户端: 你好，我要发起一个 HTTPS 请求，请给我公钥</li>
<li>服务器: 好的，这是我的证书，里面有加密后的公钥</li>
<li>客户端: 解密成功以后告诉服务器: 这是我的 (用公钥加密后的) 对称秘钥。</li>
<li>服务器: 好的，我知道你的秘钥了，后续就用它传输。</li>
</ol>
<h3 id="Q6-你在逗我么。。。。"><a href="#Q6-你在逗我么。。。。" class="headerlink" title="Q6: 你在逗我么。。。。"></a>Q6: 你在逗我么。。。。</h3><p>那权威机构的公钥又怎么传输？</p>
<h3 id="BS-存在电脑里"><a href="#BS-存在电脑里" class="headerlink" title="BS: 存在电脑里"></a>BS: 存在电脑里</h3><p>这个公钥不用传输，会直接内置在各大操作系统(或者浏览器)的出厂设置里。之所以不把每个服务器的公钥内置在电脑里，一方面是因为服务器太多，存不过来。另一方面操作系统也不信任你，凭什么你说你这个就是百度/淘宝的证书呢？</p>
<p>所以各个公司要先去权威机构认证，申请证书，然后操作系统只会存储权威机构的公钥。因为权威机构数量有限，所以操作系统厂商相对来说容易管理。如果这个权威机构不够权威，XJB 发证书，就会取消他的资格，比如可怜的沃通。。。。</p>
<h3 id="Q7-怎么知道证书有没有被篡改？"><a href="#Q7-怎么知道证书有没有被篡改？" class="headerlink" title="Q7: 怎么知道证书有没有被篡改？"></a>Q7: 怎么知道证书有没有被篡改？</h3><p>你说服务器第一次会返回证书，也就是加密以后的公钥，那我怎么知道这个证书是可靠的？</p>
<h3 id="BS-将信息-hash-值随着信息一起传递"><a href="#BS-将信息-hash-值随着信息一起传递" class="headerlink" title="BS: 将信息 hash 值随着信息一起传递"></a>BS: 将信息 hash 值随着信息一起传递</h3><p>我们都知道哈希算法的特点，它可以压缩数据，如果从函数角度来看，不管多复杂的数据(定义域可以非常大)经过哈希算法都会得到一个值，而且这个值处在某个特定(远小于定义域的范围)值域内。相同数据的哈希结果一定相同，不相同数据的哈希结果一般不同，不过也有小概率会重复，这叫哈希冲突。</p>
<p>为了确保原始证书没有被篡改，我们可以在传递证书的同时传递证书的哈希值。由于第三者无法解析数据，只能 XJB 改，那么修改后的数据在解密后，就不可能通过哈希。</p>
<p>比如说公钥就是之前的例子 <code>Hello</code>，我们假设哈希算法是获取字符串的最后一个字符，那么 <code>Hello</code> 的哈希值就是 <code>o</code>，所以加密字符串是 <code>Ifmmpp</code>。虽然公钥已知，每个人都可以解密，解密完也可以篡改，但是因为没有私钥， 所以无法正确的加密。所以它再返回给客户端的数据是无效数据，用公钥解析后会得到乱码。即使攻击者通过多次尝试碰巧能够解析，也无法通过哈希校验。</p>
<h3 id="Q8-这样可以防止第三方冒充服务器么"><a href="#Q8-这样可以防止第三方冒充服务器么" class="headerlink" title="Q8: 这样可以防止第三方冒充服务器么"></a>Q8: 这样可以防止第三方冒充服务器么</h3><h3 id="BS-也许可以"><a href="#BS-也许可以" class="headerlink" title="BS: 也许可以"></a>BS: 也许可以</h3><p>首先真正的服务器下发的内容，无法被别人篡改。他们有权威机构的公钥，所以可以解密，但是因为没有私钥，所以解密以后的信息无法加密。没有加密或者错误加密的信息被客户端用公钥解密以后，必然无法通过哈希校验。</p>
<p>但是，如果你一开始请求的就不是真的服务器，而是一个攻击者，此时的他完全有机会进行中间人攻击。我们知道第一次握手的时候服务器会下发用于证明自己身份的证书，这个证书会用预设在设备上的公钥来解密。所以要么是经过认证的证书用权威机构的私钥加密，再用权威机构解密，要么是用非权威机构的私钥加密，然后找不到公钥解密。</p>
<p>所以如果不小心安装过非权威机构的根证书，比如黑客提供的恶意证书，这时候设备上就多了一个预设的公钥，那么用恶意私钥加密的证书就能被正常解析出来。所以千万不要随便装根证书，这等于是为那些恶意证书留了一扇门。</p>
<p>当然，凡是都有两面性。我们知道 Charles 可以调试 HTTPS 通信，它的原理就是需要用户安装 Charles 的根证书，然后我们的请求会被代理到 Charles 服务器，它下发的 Charles 证书才能被正确解析。另一方面，Charles 会作为客户端，从真正的服务器哪里拿到正确的 https 证书并用于后续通信。幸好 Charles 不是流氓软件，或者它的私钥一旦泄露，对用户都会造成很大的影响。</p>
<p>我可以举一个例子，证书有多个种类，最贵的叫 EV (Extended Validation)，它需要公司营业执照等多个文件才能申请人工审核，好处也很明显，可以在浏览器地址栏左侧准确显示公司名称，比如 <a href="https://bitbucket.org/" target="_blank" rel="external">Bitbucket 的官网</a>:</p>
<p><img src="http://images.bestswifter.com/1489308655.png" alt="EV 证书左侧的名字"></p>
<p>这是客户端直连时候的正常现象。但如果你用 Charles 代理，客户端拿到的是 Charles 证书，所以会变成: </p>
<p><img src="http://images.bestswifter.com/1489308747.png" alt="代理模式下无法显示"></p>
<h3 id="Q9-HTTPS-握手会影响性能么"><a href="#Q9-HTTPS-握手会影响性能么" class="headerlink" title="Q9: HTTPS 握手会影响性能么"></a>Q9: HTTPS 握手会影响性能么</h3><p>TCP 有三次握手，再加上 HTTPS 的四次握手，会不会影响性能？</p>
<h3 id="BS-影响肯定有，但是可以接受"><a href="#BS-影响肯定有，但是可以接受" class="headerlink" title="BS: 影响肯定有，但是可以接受"></a>BS: 影响肯定有，但是可以接受</h3><p>首先，HTTPS 肯定会更慢一点，时间主要花费在两组 SSL 之间的耗时和证书的读取验证上，对称算法的加解密时间几乎可以忽略不计。</p>
<p>而且如果不是首次握手，后续的请求并不需要完整的握手过程。客户端可以把上次的加密情况直接发送给服务器从而快速恢复，具体细节可以参考 <a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="external">图解SSL/TLS协议</a>。</p>
<p>除此以外，SSL 握手的时间并不是只能用来传递加密信息，还可以承担起客户端和服务器沟通 HTTP2 兼容情况的任务。因此从 HTTPS 切换到 HTTP2.0 不会有任何性能上的开销，反倒是得益于 HTTP2.0 的多路复用等技术，后续可以节约大量时间。</p>
<p>如果把 HTTPS2.0 当做目标，那么 HTTPS 的性能损耗就更小了，远远比不上它带来的安全性提升。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>相信以上九个问题足够帮助新人了解 HTTPS 了，但这只是基本概念，关于 HTTPS 的使用(比如 iOS 上的一些具体问题)还需要不断尝试和研究。</p>
<p>文章最后打一个求职广告，长期有效，女朋友今年毕业，考研 380+，<a href="https://github.com/tinycat2017/Resume" target="_blank" rel="external">简历戳这里</a>，计算机基础还算扎实，但项目经验偏少，可以实习 6 个月以上。北京地区如果有想要招实习生的公司，欢迎联系我，方向不限，前后端皆可培养，iOS 更好(我自己教)。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;女朋友也是软件工程专业，因为快要毕业了，最近一边做毕设一边学习编程。前两天她问我 HTTPS 的问题，本来想直接扔一篇网上的教程给她。后来想了一下，那些文章大多直接介绍概念， 对新手不太友好，于是我干脆亲自给她解释一下，顺便整理了一份问答录。&lt;/p&gt;
&lt;h3 id=&quot;Q1-
    
    </summary>
    
    
      <category term="前端" scheme="http://fullstack.blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>业务爬坑与总结——开屏广告热启动实现方案</title>
    <link href="http://fullstack.blog/2017/03/09/%E4%B8%9A%E5%8A%A1%E7%88%AC%E5%9D%91%E4%B8%8E%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E5%BC%80%E5%B1%8F%E5%B9%BF%E5%91%8A%E7%83%AD%E5%90%AF%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
    <id>http://fullstack.blog/2017/03/09/业务爬坑与总结——开屏广告热启动实现方案/</id>
    <published>2017-03-09T03:51:07.000Z</published>
    <updated>2017-03-09T05:19:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>最初接下开屏广告热启动需求时，对于即将踏入一个什么样的深坑，我心里毫无概念。在当时看来，开屏广告的相关代码已经基本实现，我只要额外添加热启动功能就可以，即使算上调研设计、后端联调加上测试的时间，我也只给自己规划了一周多的时间来完成双端的需求。</p>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>所谓的开屏广告热启动是指，应用程序进入后台后(按 Home 键或者跳转到其他应用)，等待一段时间再回到应用时展示开屏广告。由于操作系统会定时清理不活跃且占内存的应用，所以此时展示开屏广告会让用户以为应用正在重新启动。由于对用户体验伤害小，甚至很多时候几乎可以做到无感知，所以目前很多日活量较高的 app 都实现了开屏广告热启动功能，常见的有微博、头条等。</p>
<p>如果不考虑最短间隔时间，每天热启动次数上限等附加限制，开屏广告热启动的核心需求其实就在于<strong>准确地检测应用切到后台再回到前台</strong>的行为。所谓的准确，指的是不漏掉真正的进入后台，也不误把普通操作当做进入后台。</p>
<p>这个需求看上去非常容易，直接调用系统 API 即可完成，而在实际开发的过程中却遇到了不少坑，我按照平台逐一分析一下，不会有太多的实现细节，主要是聊聊设计和实现思路。</p>
<h1 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h1><p>先说我最熟悉的，也是相对来说比较容易实现的 iOS 平台。</p>
<p>在实现开屏广告需求时，从设计角度来考虑，由于 <code>application:didFinishLaunchingWithOptions:</code> 函数执行结束后会自动发送通知，所以我们只需要监听 <code>UIApplicationDidFinishLaunchingNotification</code> 通知即可。在展示广告时，可以使用 <code>UIView</code> 直接盖上一张图片。不过考虑到有倒计时按钮，跳过按钮，以及将来有可能支持除了图片以外的其他格式(比如 VR 视频)，所以使用 <code>UIViewController</code> 虽然麻烦些，但也不失为一种稳妥的，方便后续拓展维护的做法。</p>
<p>具体做法就不详细描述了，感兴趣的读者可以参考 <a href="http://www.cocoachina.com/ios/20160628/16828.html" target="_blank" rel="external">无入侵的开屏广告插入方式</a>。</p>
<p>前文说过热启动需要满足一定条件，比如进入后台和再次回到前台的时间间隔必须大于某个值，否则回到桌面后快速返回应用也会出现开屏广告，带给用户的体验很差。并且这个值最好是做成服务器动态下发，好处是一旦开屏广告的逻辑出现问题，可以把间隔时间设为非常大的值，从而关闭此功能。同样是出于用户体验考虑，每天开屏广告热启动的次数也需要做限制，超出预设次数以后不再展示。</p>
<p>为了管理以上逻辑，并且与原有开屏广告逻辑有效解耦，单独抽离一个 <code>HotSplashManager</code> 类就显得很有必要。由于应用的整个生命周期内都有可能展示开屏广告，所以可以考虑设计为单例模式，并且对外统一暴露一个 <code>- (BOOL)canShowHotSplashAdvertisement</code> 方法。</p>
<p>不过由于目前项目中没有使用通知，而是与 <code>application:didFinishLaunchingWithOptions:</code> 方法强耦合。所以我接手以后的思路也是沿用前人的代码，主要是在 <code>applicationDidEnterBackground</code> 函数中通知 <code>HotSplashManager</code> 类应用进入后台。</p>
<h2 id="锁屏检测"><a href="#锁屏检测" class="headerlink" title="锁屏检测"></a>锁屏检测</h2><p>这里的第一个小坑在于锁屏同样会触发 <code>applicationDidEnterBackground</code> 函数，而从逻辑上讲，应用锁屏后再解锁并不应该被认为是一种前后台切换，而如果<strong>已经按 Home 键进入后台</strong>，这时候再锁屏/解锁就不应该影响 App <strong>进入了后台再切回前台</strong>的事实，也就是不影响开屏广告的正常展示，这里的逻辑比较绕，需要整理一下逻辑并仔细测试。</p>
<p>检测锁屏和解锁的方法有好几种， 其中有的方法不能完全兼容 iOS 9、10 两大主流版本。最终找到的有效方案是利用 Darwin 层面的通知:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 检测锁屏和解锁</span></div><div class="line"><span class="built_in">CFNotificationCenterAddObserver</span>(<span class="built_in">CFNotificationCenterGetDarwinNotifyCenter</span>(), <span class="comment">//center</span></div><div class="line">                                <span class="literal">NULL</span>, <span class="comment">// observer</span></div><div class="line">                                displayStatusChanged,</div><div class="line">                                <span class="built_in">CFSTR</span>(<span class="string">"com.apple.springboard.lockstate"</span>),</div><div class="line">                                <span class="literal">NULL</span>, <span class="comment">// object</span></div><div class="line">                                <span class="built_in">CFNotificationSuspensionBehaviorDeliverImmediately</span>);</div><div class="line">                                </div><div class="line"><span class="comment">// 接受通知后的处理</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> displayStatusChanged(<span class="built_in">CFNotificationCenterRef</span> center,</div><div class="line">                                 <span class="keyword">void</span> *observer,</div><div class="line">                                 <span class="built_in">CFStringRef</span> name,</div><div class="line">                                 <span class="keyword">const</span> <span class="keyword">void</span> *object,</div><div class="line">                                 <span class="built_in">CFDictionaryRef</span> userInfo) &#123;</div><div class="line">    <span class="comment">// 每次锁屏和解锁都会发这个通知，第一次是锁屏，第二次是解锁，交替进行</span></div><div class="line">    [[HotSplashManager sharedInstance] lockStateChanged];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果不是我的使用方式有误，那么理论上来说是拿不到准确的锁屏 or 解锁状态的，只能知道每次解锁或者锁屏都会触发这个通知，并且第一次一定是锁屏，往后依次交替，所以要在自己的 <code>HotSplashManager</code> 中管理好屏幕状态。</p>
<h2 id="自然日缓存"><a href="#自然日缓存" class="headerlink" title="自然日缓存"></a>自然日缓存</h2><p>每天展示次数有上限就意味着展示次数必须被持久化保存在本地，这可以理解为一种特殊的缓存:“仅在一个自然日内有效，跨日自动清空”。考虑到这样的需求并不是开屏广告这个业务独有，所以不妨抽取成一个基础类: <code>XXXDailyCache</code>，并且给它一个 <code>namespace</code> 的概念来针对不同业务做隔离。</p>
<p>需要强调的是，虽然很多项目都会实现自己的基础缓存类 <code>XXXCache</code>，这里我强烈反对使用继承模式，感兴趣的读者可以参考我之前的文章: <a href="https://bestswifter.com/pop/#" target="_blank" rel="external">从 Swift 的面向协议编程说开去</a> 一文的倒数第二节: “继承与组合”，说的就是这种非常常见的误用继承关系的场景。所以这里正确的做法是使用组合模式，用 <code>namespace</code> 去创建基础的 <code>XXXCache</code> 类实现缓存功能，而 <code>DailyCache</code> 则持有缓存对象并且实现按自然日删除的逻辑。</p>
<p>按自然日区分的逻辑很简单， 只要把缓存的 Key 设置为当前日期，然后每次读取之前先判断日期即可。这是比较简单的体力活，就不多费口舌了。封装得好的话，只会对外暴露三个简洁方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XXXDailyCache</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithNameSpace:(<span class="built_in">NSString</span> *)namespace;</div><div class="line">- (<span class="keyword">id</span>)getValueWithKey(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="keyword">void</span>)writeWithKey:(<span class="built_in">NSString</span> *)key value:(<span class="keyword">id</span>)value;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h2 id="开屏广告热启动"><a href="#开屏广告热启动" class="headerlink" title="开屏广告热启动"></a>开屏广告热启动</h2><p>之前的同事已经实现了开屏广告功能，他们提供了一个 <code>showSplashAD</code> 的方法，方法内部会把根 <code>UIView</code> 的 <code>rootViewController</code> 设置为开屏广告的 ViewController。</p>
<p>现在添加好了相关判断条件以后，只需要简单改造一下 app 进入前台的回调即可，对原来业务的改动相对来说很小:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)applicationWillEnterForeground:(<span class="built_in">UIApplication</span> *)application &#123;</div><div class="line">    <span class="keyword">if</span> ([[HotSplashManager sharedInstance] canShowSplashAd]) &#123;</div><div class="line">        [<span class="keyword">self</span> showSplashAD];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总的来说 iOS 的实现相当简单， 做好基础类的封装，注意判断一下锁屏问题就可以了。</p>
<h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><p>首先 iOS 存在的问题安卓都有，所以同样需要封装自然日失效的 <code>DailyCache</code>，处理锁屏逻辑则是使用了通知机制，监听系统的通知。</p>
<p>为了可复用性，我们可以封装出一个单独的类来监听锁屏通知，并记录当前状态，以便将来可以对外提供相应的服务:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScreenLockReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> isScreenOff = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span> (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)) &#123;</div><div class="line">            isScreenOff = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (intent.getAction().equals(Intent.ACTION_SCREEN_ON)) &#123;</div><div class="line">            isScreenOff = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后实例化这个 <code>ScreenLockReceiver</code> 并为它添加好过滤:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ScreenLockReceiver screenLockReceiver = <span class="keyword">new</span> ScreenLockReceiver();</div><div class="line">IntentFilter lockFilter = <span class="keyword">new</span> IntentFilter();</div><div class="line">lockFilter.addAction(Intent.ACTION_SCREEN_ON);</div><div class="line">lockFilter.addAction(Intent.ACTION_SCREEN_OFF);</div><div class="line">lockFilter.addAction(Intent.ACTION_USER_PRESENT);</div><div class="line">registerReceiver(screenLockReceiver, lockFilter);</div></pre></td></tr></table></figure>
<h2 id="前后台切换"><a href="#前后台切换" class="headerlink" title="前后台切换"></a>前后台切换</h2><p>由于安卓没有提供系统级别的前后台切换通知，所以不得不自己手动实现。第一种思路是实现 <code>onTrimMemory</code> 函数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTrimMemory</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> level)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (level == ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) &#123;</div><div class="line">        <span class="comment">// Get called every-time when application went to background.</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它的原理来源于官网对于 <code>onTrimMemory</code> 的解释，当 level 的值是 <code>TRIM_MEMORY_UI_HIDDEN</code> 时，按照文档的解释是应用程序进入后台，需要释放 UI 资源。基于这种思路的前后台切换检测在 <a href="http://stackoverflow.com/a/19920353" target="_blank" rel="external">Stack Overflow</a> 上得到了非常多的赞同。然而根据我们的测试，在某些高端机型上，即使应用程序进入后台，由于内存相对充足，并不会触发上述方法。</p>
<p>考虑到官方文档没有明确说明进入后台时一定会调用 <code>onTrimMemory</code> 方法， 很多时候是开发者自己的总结，我们最终放弃了这种实现思路。</p>
<p>实际上还有一种最老土，也相对来说最准确的判断方法。应用进入后台时，Activity 会调用 <code>onPause</code> 方法，回到前台又会调用 <code>onResume</code> 方法。虽然在切换 Activity 时也会走这样的流程，但是两个方法的调用时间间隔非常短，即使考虑到低端机的性能问题， 两秒钟也足够完成一次页面跳转了。所以只需要记录 <code>onPause</code> 的时间戳，再拿到 <code>onResume</code> 的时间戳，两者做差比较即可。</p>
<p>如果之前的应用封装的好的话，应该会有一个继承自系统的 <code>Activity</code> 的子类，比如叫做 <code>BaseActivity</code>。显然以上逻辑应该在这个 <code>BaseActivity</code> 里完成， 不过一个应用中并不一定所有的视图都继承自这个 <code>BaseActivity</code>，我们还有可能使用 <code>FragmentActivity</code> 及其子类，所以在对应的 <code>BaseFragmentActivity</code> 中也要添加类似的逻辑。</p>
<h2 id="展示开屏广告"><a href="#展示开屏广告" class="headerlink" title="展示开屏广告"></a>展示开屏广告</h2><p>与 iOS 不同的是，进入前台事件的直接处理逻辑应该写在 <code>HotSplashManager</code> 类中，而非 iOS 的 <code>Appdelegate</code>，唤起开屏广告的方式也略有不同。在 <code>HotSplashManager</code> 中我们可以直接拿到当前展示的 activity(<code>BaseActivity</code> 把自己传过来)，然后调用它的 <code>startActivity</code> 方法就可以唤起开屏广告所在的 Activity 了，注意关掉动画效果。</p>
<p>开屏广告的 <code>SplashActivity</code> 也需要对唤起方式做区分，判断自己是冷启动展示还是热启动展示。如果是热启动展示，不需要涉及后续的引导页流程，而是直接调用 <code>this.finish()</code> 即可。</p>
<h2 id="多进程通信"><a href="#多进程通信" class="headerlink" title="多进程通信"></a>多进程通信</h2><p>以上功能完成以后，基本上开屏广告热启动的需求就算开发完了，直到测试时有用户反馈全屏查看图片时大概率也会展示开屏广告。经过排查后发现，我们的应用中诸如查看图片、打开网页等操作都会放到其他进程中完成，从而避免与主进程争夺内存，导致 OOM。</p>
<p>多进程场景下会有多个 Application 和 Activity 实例在同时运行。在主进程切换到子进程的过程中，实际上调用到的是主进程的 <code>onPause</code> 和子进程的 <code>onResume</code>，子进程回到主进程时调用的则是子进程的 <code>onPause</code> 和主进程的 <code>onResume</code>。</p>
<p>不难看出对于主进程而言，<code>onPause</code> 和下一次 <code>onResume</code> 之前的时间间隔至少是在子进程中停留的时间。所以容易出现前后台切换的误报。</p>
<p>解决这个问题有多个思路，但任何基于 Application 类，利用内存存储数据的做法均不可能实现，应该避免在这种思路上浪费不必要的时间。首先可以考虑 AIDL、Binder 等多进程通信模型，不过网上搜了一圈，普遍实现起来比较啰嗦，而且实际上我这里的需求并不是通信，而是传递一个非常小的数据，表示 App 是否进入子进程，所以这些方案首先排除。</p>
<p>由于没有找到合适的跨进程内存共享方案，所以接下来考虑的是文件共享的方式，代表技术有 ContentProvider。不过 ContentProvider 实际上是对下层具体文件读写实现方案的抽象封装，提供了一套 CURD 接口。也就是说我还得自己实现文件的读写。考虑到实现成本过大，而需求比较简单，也排除了这种方案。</p>
<p>最后考虑到通知，先调研了 <code>LocalBroadcastManager</code> 这种本地通知，看了一下源码以后发现不适用于跨进程通信，内部其实是利用 <code>context</code> 参数拿到了 <code>ApplicationContext</code>，然后实现了简单的观察者模式。感兴趣的读者可以阅读文章末尾的参考资料。</p>
<p>最终的解决方案是选择了普通的 <code>BroadcastManager</code>，注意添加 filter 过滤一下，以及设置好包名，限制广播的接收者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">new</span> Intent(BROADCAST_KEY);</div><div class="line">intent.setPackage(getPackageName());</div><div class="line">intent.putExtra(<span class="string">"flag"</span>, <span class="keyword">false</span>);  <span class="comment">// 通知主进程 application: "已经进入子进程"</span></div><div class="line">sendBroadcast(intent);</div></pre></td></tr></table></figure>
<h2 id="其他的一些思考"><a href="#其他的一些思考" class="headerlink" title="其他的一些思考"></a>其他的一些思考</h2><p>开发过程中的坑远远不止上面列出的这些，比如还顺手解决了一个弱引用过早释放的 bug 和一个内存泄漏的问题。此外，在开发的过程中对 context 概念还比较模糊，Java 闭包对捕获的变量的处理也挺有意思，不过考虑到大部分都是 Java 语法，就不在这篇业务学习总结里面多啰嗦了，待我整理一下，另起一篇文章专门讨论。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol>
<li><a href="http://blog.csdn.net/xyz_fly/article/details/18970569" target="_blank" rel="external">Android编程之LocalBroadcastManager源码详解</a></li>
<li><a href="http://www.trinea.cn/android/localbroadcastmanager-impl/" target="_blank" rel="external">LocalBroadcastManager 的实现原理，还是 Binder？</a></li>
<li><a href="http://www.dundunwen.com/article/765314db-4072-4022-bb21-3f1e64ea54ba.html" target="_blank" rel="external">LocalBroadcastManager分析</a></li>
<li><a href="http://www.cocoachina.com/ios/20160628/16828.html" target="_blank" rel="external">无入侵的开屏广告插入方式</a></li>
<li><a href="http://stackoverflow.com/questions/4414171/how-to-detect-when-an-android-app-goes-to-the-background-and-come-back-to-the-fo" target="_blank" rel="external">How to detect when an Android app goes to the background and come back to the foreground</a></li>
<li><a href="https://gold.xitu.io/entry/57c3841d0a2b58006cf9f7f5" target="_blank" rel="external">Android 探索之 BroadcastReceiver 具体使用以及安全性探究</a></li>
</ol>
<p>以及其他阅读过但没有记录下来的优秀文章，感谢前辈们的分享。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最初接下开屏广告热启动需求时，对于即将踏入一个什么样的深坑，我心里毫无概念。在当时看来，开屏广告的相关代码已经基本实现，我只要额外添加热启动功能就可以，即使算上调研设计、后端联调加上测试的时间，我也只给自己规划了一周多的时间来完成双端的需求。&lt;/p&gt;
&lt;h1 id=&quot;需求&quot;
    
    </summary>
    
    
      <category term="Android" scheme="http://fullstack.blog/tags/Android/"/>
    
      <category term="Java" scheme="http://fullstack.blog/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>异步与回调的设计哲学</title>
    <link href="http://fullstack.blog/2017/02/26/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%9B%9E%E8%B0%83%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/"/>
    <id>http://fullstack.blog/2017/02/26/异步与回调的设计哲学/</id>
    <published>2017-02-26T14:23:20.000Z</published>
    <updated>2017-02-26T14:25:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文的例子用 JavaScript 语法给出，希望读者至少有使用过 Promise 的经验，如果用过 async/await 则更好，对于客户端的开发者，我相信语法不是阅读的瓶颈，思维才是，因此也可以了解一下异步编程模型的演变过程。</p>
<h1 id="异步编程入门"><a href="#异步编程入门" class="headerlink" title="异步编程入门"></a>异步编程入门</h1><h2 id="CPS"><a href="#CPS" class="headerlink" title="CPS"></a>CPS</h2><p>CPS 的全称是 (Continuation-Passing Style)，这个名词听上去比较高大上(背后涉及到很多数学方面的东西)，实际上如果只是想了解什么是 CPS 的话，并不是太难。</p>
<p>我们看下面这段代码，你肯定会觉得太简单了:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int a = sum(<span class="number">1</span>, <span class="number">2</span>);   <span class="comment">// 第一行业务代码 </span></div><div class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 第二行业务代码</span></div></pre></td></tr></table></figure>
<p>隐藏在这两行代码背后的是串行编程的思想，也就是说第一行代码执行出结果以后才会执行第二行代码。</p>
<p>可如果 <code>sum</code> 这个函数耗时比较久怎么办呢，一般我们不会选择等待它执行完，而是提供一个回调，在执行完耗时操作以后再执行回调，同时避免阻塞主线程:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">asum</span>(<span class="params">a, b, callback</span>) </span>&#123;</div><div class="line">	<span class="keyword">const</span> r = a + b;</div><div class="line">	setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">		callback(r);</div><div class="line">	&#125;, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">asum(<span class="number">1</span>, <span class="number">2</span>, r =&gt; <span class="built_in">console</span>.log(r));</div></pre></td></tr></table></figure>
<p>于是，业务方不用等待 <code>asum</code> 的返回结果了，现在它只要提供一个回调函数。这种写法就叫做 CPS。</p>
<p>CPS 可以总结为一个很重要的思想: <strong>“我不用等执行结果，我先假设结果已经有了，然后描述一下如何利用这个结果，至于调用的时机，由结果提供方负责管理”</strong>。</p>
<h2 id="没什么卵用的-CPS"><a href="#没什么卵用的-CPS" class="headerlink" title="没什么卵用的 CPS"></a>没什么卵用的 CPS</h2><p>扯了这么多 CPS，其实我想说的是，很多介绍 Promise 的文章上来就谈 CPS，更有甚者直接聊起了 CPS 的背后数学模型。实际上 CPS 对异步编程没什么卵用，主要是它的概念太普遍，太容易理解了，我敢打赌几乎所有的开发者都或多或少的用过 CPS。</p>
<p>毕竟回调函调每个人都用过，只不过你不一定知道这是 CPS 而已。比如随便举一个 AFNetworking 中的例子:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLSessionDataTask</span> *dataTask = [manager dataTaskWithRequest:request completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>, response, responseObject);</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>写过 JavaScript 的人应该都接触过 Promise，首先明确一个概念，Promise 是一些列规范的总称，现有的规范有 Promise/A、Promise/B、Promise/A+ 等等，每个规范都有自己的实现，当然也可以自己提供一个实现，只要能满足规范中的描述即可。</p>
<p>写过 Promise 或者 RAC/RxSwift 的读者估计对一长串 <code>then</code> 方法记忆深刻，不知道大家是否思考过，为什么会设计这种链式写法呢？</p>
<p>我当然不想听到什么“方法调用以后还返回自己”这种废话，要能反复调用 then 方法必然要返回同一个类的对象啊。。。要想搞清楚为什么要这么设计，或者为什么可以这么设计，我们先来看看传统的 CPS(基于回调) 写法如何处理嵌套的异步事件。</p>
<p>如果我需要请求第一个接口，并且用这个接口返回的数据请求下一个接口，那代码看起来大概是这样的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">request(url1, parms1, response =&gt; &#123;</div><div class="line">    <span class="comment">// 处理 response</span></div><div class="line">    request(url2, params2, response =&gt; &#123;</div><div class="line">        <span class="comment">// 处理第二个接口的数据</span></div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>上述代码用伪代码写起来看上去还能接受，不过可以参考 OC 的繁琐代码，试想一个双层嵌套就已经如此麻烦， 三层嵌套该怎么写是好呢？</p>
<h2 id="CPS-的本质"><a href="#CPS-的本质" class="headerlink" title="CPS 的本质"></a>CPS 的本质</h2><p>我们抽象一下上面的逻辑，CPS 的含义是不直接等待异步数据返回，而是传入一个回调函数来处理未来的数据。换句话讲:</p>
<p><strong>回调事件是一个普通事件，内部可能还会发起一个异步事件</strong></p>
<p>这种世界观的好处在于，通过事件的嵌套形成了一套递归模型，理论上能够解决任意多层的嵌套。当然缺点也是显而易见的，<strong>语义上的嵌套最终导致了代码上的嵌套</strong>，影响了可读性和可维护性。</p>
<p>这种嵌套模型可以用下面这幅图来表示:</p>
<p><img src="http://images.bestswifter.com/1488098032.png" alt="CPS 回调的本质"></p>
<p>可以看到图中只有两种图形，椭圆形表示一般性事件(回调也是一个事件)，而圆角矩形表示一个异步过程，当执行完以后，就会接着执行它连接着的事件。</p>
<h2 id="Promise-的本质"><a href="#Promise-的本质" class="headerlink" title="Promise 的本质"></a>Promise 的本质</h2><p>当然，我们是有办法解决嵌套问题的，俗话说得好:</p>
<blockquote>
<p>任何计算机问题都可以通过添加一个中间层来解决</p>
</blockquote>
<p>而 Promise 的本质则是下面这幅图:</p>
<p><img src="http://images.bestswifter.com/1488098234.png" alt="Promise 的本质"></p>
<p>可以看到，我们引入了新的 Promise 层，一个 Promise 内部封装了异步过程，和异步过程结束以后的回调。如果这个回调的内部可以生成一个新的 Promise。于是嵌套模型就变成了链式模型，这也是为什么我们经常能看到 <code>then</code> 方法的调用链。</p>
<p>需要强调的是，即使你用了 Promise，也可以在回调函数中直接执行异步过程，这样就回到了嵌套模型。所以 Promise 的精髓实际上在于回调函数中返回一个新的 Promise 对象。</p>
<h2 id="Promise-的基本概念"><a href="#Promise-的基本概念" class="headerlink" title="Promise 的基本概念"></a>Promise 的基本概念</h2><p>数据结构学得好的读者看到上面这幅图应该会想到链表。不过一个 Promise 内部可以持有多个新的 Promise，所以采用的不是链表结构而是有些类似于多叉树。简化版的 Promise 定义如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">resolver</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.state = PENDING;</div><div class="line">  <span class="keyword">this</span>.value = <span class="keyword">void</span> <span class="number">0</span>;</div><div class="line">  <span class="keyword">this</span>.queue = [];   <span class="comment">// 持有接下来要执行的 promise</span></div><div class="line">  <span class="keyword">if</span> (resolver !== INTERNAL) &#123;</div><div class="line">    safelyResolveThen(<span class="keyword">this</span>, resolver);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对一个 Promise 对象调用 <code>then</code> 方法，实际上是判断 Promise 的状态是否还是 <code>PENDING</code>，如果是的话就生成一个新的 Promise 保存在数组中。否则直接执行 then 方法参数中 block。</p>
<p>当一个 Promise 内部执行完以后，比如说是进入了 <code>FULLFILLED</code> 状态，就会遍历自己持有的所有的 Promise 并告诉他们也去执行 <code>resolve</code> 方法，进入 <code>REJECTED</code> 状态也是同理。</p>
<p>如果能够理解这层思想，你就可以理解为什么有前后关系顺序的几个异步事件可以用 <code>then</code> 这种同步写法串联了。因为调用 <code>then</code> 实际上是预先保留了一个回调，只有当上一个 Promise 结束以后才会通知到下一个 Promise。</p>
<h2 id="Promise-小细节"><a href="#Promise-小细节" class="headerlink" title="Promise 小细节"></a>Promise 小细节</h2><p>关于 Promise 的实现原理，这篇文章不想描述太多，感兴趣的读者可以参考 <a href="https://zhuanlan.zhihu.com/p/25178630" target="_blank" rel="external">深入 Promise(一)——Promise 实现详解</a>，读完以后可以看一下作者的后续文章中的四个题目，检验一下是否真的理解了: <a href="https://zhuanlan.zhihu.com/p/25198178" target="_blank" rel="external">深入 Promise(二)——进击的 Promise</a>。</p>
<p>这里我只想强调一下几个容易理解错的地方。首先，Promise 会接受一个函数作为自己的参数，也就是下面代码中的 <code>fucntion (resolve, reject){ /* do something */ }</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p =	<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">	resolve(<span class="string">'hello'</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(ppppp);</div><div class="line"><span class="comment">// 打印出 Promise &#123; 'hello' &#125; 而不是 Promise &#123; 'pedding' &#125;</span></div><div class="line"><span class="comment">// 证明 Promise 已经在创建时就决议</span></div></pre></td></tr></table></figure>
<p>在创建 Promise 时，这个参数函数就会被执行， 执行这个函数需要两个参数 <code>resoleve</code> 和 <code>reject</code>，它并不是通过 <code>then</code> 方法提供而是由 Promise 在内部自己提供，换句话说这两个参数是已知的。</p>
<p>因此如果按照上述代码来写， 在创建 Promise 时就会立刻调用 <code>resolve(&#39;hello&#39;)</code>，然后把状态标记为 <code>FULLFILLED</code> 并且让内部的 <code>value</code> 值为 <code>&quot;hello&quot;</code>。这样后来执行 <code>then</code> 的时候会判断到 Promise 已经决议，直接把 <code>value</code> 的值放到 then 的闭包中，而且这个过程是异步执行(参考文章中 immediate 的使用)。</p>
<p>有的文章会谈到 Promise 的错误处理，实际上这里没有什么高深的学问或者黑科技。如果在 Promise 内部调用 <code>setTimeout</code> 异步的抛出错误，外面还是接不到。</p>
<p>Promise 处理错误的原则是提供了一个 <code>reject</code> 回调，并且用 <code>reject</code> 方法来代替抛出错误的做法。这样做相当于约定了一套错误协议，把错误直接转嫁到业务方的逻辑中。</p>
<p>另一个需要重点理解的是 <code>then</code> 方法提供的闭包中，返回的内容，因为这才是链式模型的核心。</p>
<p>在 Promise 内部的 <code>doResolve</code> 方法中会有以下关键判断:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> then = getThen(value);</div><div class="line"><span class="keyword">if</span> (then) &#123;</div><div class="line">    safelyResolveThen(self, then);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    self.state = FULFILLED;</div><div class="line">    self.value = value;</div><div class="line">    self.queue.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">queueItem</span>) </span>&#123;</div><div class="line">    queueItem.callFulfilled(value);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此如果这里的 value 不是基本类型，就会重新走一遍 <code>safelyResolveThen</code>，相当于重新解一遍 Promise 了。</p>
<p>所以正确的异步嵌套逻辑应该是: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p =	<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">	resolve(<span class="string">'hello'</span>);</div><div class="line">&#125;)</div><div class="line">p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">	<span class="built_in">console</span>.log(value);</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">		resolve(<span class="string">'world'</span>)</div><div class="line">	&#125;);</div><div class="line">&#125;).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">	<span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 第一行打印出 hello</span></div><div class="line"><span class="comment">// 第二行打印出 world</span></div></pre></td></tr></table></figure>
<h1 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器 Generator"></a>生成器 Generator</h1><p>我们先看一个 Python 中的例子，如何打印斐波那契数列的前五个元素:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fab</span><span class="params">(max)</span>:</span> </div><div class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> </div><div class="line">    <span class="keyword">while</span> n &lt; max: </div><div class="line">        <span class="keyword">print</span> b </div><div class="line">        a, b = b, a + b </div><div class="line">        n = n + <span class="number">1</span></div></pre></td></tr></table></figure>
<p>得益于 Python 简洁的语法，函数实现仅用了六行代码:</p>
<p><img src="http://images.bestswifter.com/1488103781.png" alt="fab 函数"></p>
<p>不过缺点在于， 每次调用函数都会打印所有数字，不能实现按需打印:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> n <span class="keyword">in</span> fab(<span class="number">5</span>): </div><div class="line">    <span class="keyword">print</span> n</div></pre></td></tr></table></figure>
<p>我们先不考虑为什么 <code>fab(5)</code> 能放在 <code>in</code> 关键字后面，至少能分次打印就意味着我们需要一个对象，内部保存上一次的结果，这样才能正确的生成下一个值。</p>
<p>感兴趣的读者可以用对象来实现一下上述需求， 并且对比一下引入对象后带来的复杂度增加。一种既不增加复杂度，也能保留上下文的技术是使用生成器，只需要修改一个单词即可:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fab</span><span class="params">(max)</span>:</span> </div><div class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> </div><div class="line">    <span class="keyword">while</span> n &lt; max: </div><div class="line">        <span class="keyword">yield</span> b  <span class="comment">#原来是 print b</span></div><div class="line">        a, b = b, a + b </div><div class="line">        n = n + <span class="number">1</span></div></pre></td></tr></table></figure>
<p><code>yield</code> 关键字的含义是 <strong>当外界调用 next 方法时生成器内部开始执行，直到遇到 yield 关键字，此时把 yield 后面的值传递出去作为 next() 的结果，然后继续执行函数，直到再次遇到 yield 方法时暂停</strong>。</p>
<h2 id="Generator-in-JavaScript"><a href="#Generator-in-JavaScript" class="headerlink" title="Generator in JavaScript"></a>Generator in JavaScript</h2><p>上面举 Python 的例子是因为生成器在 Python 中最为简单，最好理解。在 JavaScript 中，生成器的概念稍微复杂一点，主要涉及两个变化。</p>
<ol>
<li>要求在 function 后面加上星号(*) 表示这是一个生成器而不是普通函数。</li>
<li><code>next()</code> 方法可以传递参数，在生成器内部表现为 yield 的返回值。</li>
</ol>
<p>举个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span>(<span class="params">count</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(count);</div><div class="line">	<span class="keyword">const</span> result = <span class="keyword">yield</span> <span class="number">100</span></div><div class="line">	<span class="built_in">console</span>.log(result + count);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> g = generator(<span class="number">2</span>);  <span class="comment">// 什么都不输出</span></div><div class="line"><span class="built_in">console</span>.log(g.next().value);  <span class="comment">// 第一次打印 2，随后打印 100</span></div><div class="line">g.next(<span class="number">9</span>); <span class="comment">// 打印 11</span></div></pre></td></tr></table></figure>
<p>逐行解释一下:</p>
<ol>
<li>调用 <code>generator</code> 时，生成器并没有执行，所以什么都没有输出。</li>
<li>调用 <code>g.next</code> 时，函数开始执行，打印 <code>2</code>，遇到 yield，拿到了 yield 生成的内容，也就是 100，传递给 <code>next()</code> 的调用结果，所以第二行打印 100。</li>
<li>再次调用 <code>next()</code> 方法，生成器内部恢复执行，由于 <code>next()</code> 方法传入参数 9，所以 <code>result</code> 的值是 9，第三行打印 11。</li>
</ol>
<p>可见 JavaScript 中的生成器通过 <code>yield value</code> 和<code>next(value)</code> 实现了值的内外双向传递。</p>
<h2 id="Generator-的实现"><a href="#Generator-的实现" class="headerlink" title="Generator 的实现"></a>Generator 的实现</h2><p>我不知道 Generator 在 JavaScript 和 Python 中的实现原理，然而用 Objective-C 确实可以模拟出来。考虑到生成器内部 <strong>运行 -&gt; 等待 -&gt; 恢复运行</strong> 的特点，信号量是最佳的实现方案。</p>
<p><code>yield</code> 实际上就是信号量的 <code>wait</code> 方法，而 <code>next()</code> 实际上就是信号量的 <code>signal</code> 方法。当然还要处理好数据的交互问题。总的来说思路还是比较清晰的。</p>
<h1 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h1><p>我们先举一个例子，看一下 Promise 的使用，每次调用函数 <code>p()</code> 都会生成一个新的 Promise 对象，内部的操作是把参数加一并返回，不妨把函数 p 想象成某个耗时操作。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">p</span>(<span class="params">t</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">		setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">			resolve(t + <span class="number">1</span>);</div><div class="line">		&#125;, t);</div><div class="line">	&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设我需要反复的、线性的执行这个耗时操作，代码将是这样的: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">p(<span class="number">0</span>).then( <span class="function"><span class="params">r</span> =&gt;</span> &#123;</div><div class="line">	<span class="built_in">console</span>.log(r);</div><div class="line">	<span class="keyword">return</span> p(r);</div><div class="line">&#125;).then( <span class="function"><span class="params">r</span> =&gt;</span> &#123;</div><div class="line">	<span class="built_in">console</span>.log(r);</div><div class="line">	<span class="keyword">return</span> p(r);</div><div class="line">&#125;).then( <span class="function"><span class="params">r</span> =&gt;</span> &#123;</div><div class="line">	<span class="built_in">console</span>.log(r);</div><div class="line">	<span class="keyword">return</span> p(r);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可见我们调用三次 <code>then</code> 方法，执行了三次加一操作，因此会有三行输出，分别是 1、2、3。</p>
<h2 id="回调改为线性"><a href="#回调改为线性" class="headerlink" title="回调改为线性"></a>回调改为线性</h2><p>文章的一开头就说了，代码总是线性执行， 遇到异步操作不会进行等待，而是直接设置好回调函数并继续向后执行。</p>
<p>实际上，如果借助于 Generator 暂停、恢复的特性，我们可以用同步的方式来写异步代码。比如我们先定义一个生成器 <code>linear()</code> 表示内部将要线性执行异步代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">linear</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">const</span> r1 = <span class="keyword">yield</span> p(<span class="number">0</span>);</div><div class="line">	<span class="built_in">console</span>.log(r1);</div><div class="line">	<span class="keyword">const</span> r2 = <span class="keyword">yield</span> p(r1);</div><div class="line">	<span class="built_in">console</span>.log(r2);</div><div class="line">	<span class="keyword">const</span> r3 = <span class="keyword">yield</span> p(r2);</div><div class="line">	<span class="built_in">console</span>.log(r3);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到 yield 的值是一个 Promise 对象，为了拿到这个对象，需要调用 <code>g.next().value</code>。因此为了让第一个输出打印来，代码是这样的: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">g.next().value.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;  <span class="comment">// 其实是 Promise.then 的模式</span></div><div class="line">    <span class="comment">// 正如上一节 Generator 的例子中所述，第一个 next 会启动 Generator，并且卡在第一个 yield 上</span></div><div class="line">    <span class="comment">// 为了让程序向后执行，还需要再调用一次 next，其中的参数 0 会赋值给 r1。</span></div><div class="line">	g.next(<span class="number">0</span>).value.then()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>如何模拟完整的三个 Promise 调用呢，这要求我们的代码不断向内迭代，同时用一个值保存上一次的结果:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> t = <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> g = linear();</div><div class="line">g.next().value.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">	t = value;</div><div class="line">	g.next(t).value.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">		t = value;</div><div class="line">		g.next(t).value.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">			t = value;</div><div class="line">			g.next(t)</div><div class="line">		&#125;)</div><div class="line">	&#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这种写法的运行结果和之前用 <code>then</code> 语法的运行结果完全一致。</p>
<p>有的读者可能会想问，这种写法完全没有看到好处啊，反而像是回退到了最初的模式，各种嵌套不利于代码阅读和理解。</p>
<p>然而仔细观察这段代码就会发现，嵌套逻辑中更多的是架构逻辑而非业务逻辑，业务逻辑都放在 Promise 内部实现了，因此这里的复杂代码实际上是可以做精简的，它是一个结构高度一致的递归模型。</p>
<p>我们注意到 <code>g.next().value.then</code>的内部实际上是重复了外面的调用过程，如何描述这样的递归呢，有一个小技巧，只要在最外层包一个函数，然后递归执行函数就行:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 递归必然要有可以递归的函数，因此我们在外面包装一层函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursive</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	g.next(t).value.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">		t = value;</div><div class="line">		<span class="keyword">return</span> value;</div><div class="line">	&#125;).then( <span class="function"><span class="params">result</span> =&gt;</span> recursive())</div><div class="line">&#125;</div><div class="line"></div><div class="line">recursive();</div></pre></td></tr></table></figure>
<p>然而有一个问题在于，我们必须在 <code>recursive()</code> 函数外面创建生成器 <code>g</code>，否则放在函数内部就会导致递归创建新的。因此我们可以加一个内部函数处理核心的递归问题，而外部函数处理生成器和临时变量的创建:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursive</span>(<span class="params">generator</span>) </span>&#123;</div><div class="line">	<span class="keyword">let</span> t; <span class="comment">// 临时变量，用来存储</span></div><div class="line">	<span class="keyword">var</span> g = linear();  <span class="comment">// 创建整个递归过程中唯一的生成器</span></div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">_recursive</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		g.next(t).value.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">			t = value;</div><div class="line">			<span class="keyword">return</span> value;</div><div class="line">		&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> _recursive())</div><div class="line">	&#125;</div><div class="line">	_recursive();</div><div class="line">&#125;</div><div class="line"></div><div class="line">recursive(linear);</div></pre></td></tr></table></figure>
<p>可以看到这个 <code>recursive</code> 函数完全与业务无关，对于任何生成器函数，比如说叫 g，都可以通过 <code>recursive(g)</code> 来进行调用。</p>
<p>这也就通过实际例子简单的证明了即使是异步事件也可以采用同步写法。</p>
<p>需要注明的是，这<strong>并不是</strong> async/await 语法的真正实现，这种写法的问题在于，await 外面的每一层函数都要标注为 async，然而没办法把每一个函数都转换成生成器，然后调用 <code>recursive()</code></p>
<p>感兴趣的同学可以了解一下 <a href="https://goo.gl/jlXboV" target="_blank" rel="external">babel 转换前后的代码</a>。</p>
<h2 id="“同步”-写法的设计哲学"><a href="#“同步”-写法的设计哲学" class="headerlink" title="“同步” 写法的设计哲学"></a>“同步” 写法的设计哲学</h2><p>标记了 async 的函数返回结果总是一个 Promise 对象，如果函数内部抛出了异常，就会调用 reject 方法并携带异常信息。否则就会把函数返回值作为 resolve 函数的参数调用。</p>
<p>理解了这一点以后，我们会发现 async/await 其实是<strong>异步操作的向外转移</strong>。</p>
<p>比如说 p 是一个 Promise 对象，我们可能会这样写: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> value = <span class="keyword">await</span> p;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'value = '</span> + value);</div><div class="line">  <span class="keyword">return</span> value;</div><div class="line">&#125;</div><div class="line">test().then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value));</div></pre></td></tr></table></figure>
<p>我们一定程度上可以把 <code>test</code> 当做生成器来看:</p>
<ol>
<li>调用 test 方法时，首先会执行 test 内部的代码，直到遇到 await。</li>
<li>test 方法暂时退出，执行正常的逻辑，此时 test 的返回值尚不可用，但是它是一个 Promise，可以设置 then 回调。</li>
<li>await 等待的异步操作结束，test 方法返回，执行 then 回调</li>
</ol>
<p>因此我们发现异步操作并没有消失，也不可能消失，只是从 <code>await</code> 的地方转移到了外面的 <code>async</code> 函数上。如果这个函数的返回值有用，那么外部还得使用 <code>await</code> 进行等待，并且把方法标记为 <code>async</code>。</p>
<p>所以个人建议在使用 <code>await</code> 关键字的时候，首先应该判断对异步操作的依赖情况，比如以下场景就非常合适:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> sendRequest(url) &#123;</div><div class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);  <span class="comment">// 异步请求网络</span></div><div class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> asyncStore(response);  <span class="comment">// 得到结果后异步存储数据</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>考虑到 <code>await</code> 会阻塞执行，如果某个 Promise 后面的代码任然需要执行(比如存储、统计、日志等)，则不建议盲目使用 <code>await</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> s = <span class="keyword">await</span> fetch(url);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'这里输出不了啊'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/" target="_blank" rel="external">Python yield 使用浅析</a></li>
<li><a href="http://liubin.org/promises-book/" target="_blank" rel="external">JavaScript Promise迷你书（中文版）</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzIwNjQwMzUwMQ==&amp;mid=2247484976&amp;idx=1&amp;sn=af2a8b2cabdef9f9396120ca1dd0eae5&amp;chksm=972364f2a054ede406670bf591e0723655c207994a92f7620d4392b66c467610d4be55feab9d#rd" target="_blank" rel="external">36个代码块，带你读懂异常处理的优雅演进</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25178630" target="_blank" rel="external">深入 Promise(一)——Promise 实现详解</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文的例子用 JavaScript 语法给出，希望读者至少有使用过 Promise 的经验，如果用过 async/await 则更好，对于客户端的开发者，我相信语法不是阅读的瓶颈，思维才是，因此也可以了解一下异步编程模型的演变过程。&lt;/p&gt;
&lt;h1 id=&quot;异步编程入门&quot;&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://fullstack.blog/tags/JavaScript/"/>
    
      <category term="Promise" scheme="http://fullstack.blog/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>复盘微博短链接盗窃门</title>
    <link href="http://fullstack.blog/2017/02/17/%E5%A4%8D%E7%9B%98%E5%BE%AE%E5%8D%9A%E7%9F%AD%E9%93%BE%E6%8E%A5%E7%9B%97%E7%AA%83%E9%97%A8/"/>
    <id>http://fullstack.blog/2017/02/17/复盘微博短链接盗窃门/</id>
    <published>2017-02-17T14:06:10.000Z</published>
    <updated>2017-02-17T14:07:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>这不是意外，不是 bug，是蓄谋已久的阴谋! 不知道阅读完以后，你会不会和我一样心里发寒</strong></p>
<h1 id="事件背景"><a href="#事件背景" class="headerlink" title="事件背景"></a>事件背景</h1><p>前两天传出了新浪微博利用短链接恶意盗取用户收益的事件，可能很多吃瓜群众还不是特别明白是咋回事。这里我简单复盘一下，顺便聊聊个人的见解。</p>
<p>事情最初由 @im61 的这张图片引起:</p>
<p><img src="http://images.bestswifter.com/1487336629.png" alt=""></p>
<h1 id="利益分析"><a href="#利益分析" class="headerlink" title="利益分析"></a>利益分析</h1><p>首先要知道苹果的 iTunes 联盟，这个可以算是苹果官方的推广平台，具体介绍<a href="https://itunes.phgconsole.performancehorizon.com/login/itunes/zh_cn" target="_blank" rel="external">看这里</a>，我没有用过，不过概括来说这个联盟就是一个平台，推广者帮忙推广 App，一旦有用户产生下载行为，推广者就可以获得收益。</p>
<p>这个联盟显然是一个三方平台，对推广者和应用开发者来说是双赢的局面，前者收获推广费用，后者获得下载流量，从而获得盈利。</p>
<p>为了标记某一次下载背后的推广者是谁(这样才好分成)，苹果为每一个推广者提供了推广 ID(其实还有活动码，不过不是重点，所以略过)，比如说某个应用的下载地址可能是:</p>
<blockquote>
<p><a href="https://itunes.apple.com/bestswifter" target="_blank" rel="external">https://itunes.apple.com/bestswifter</a></p>
</blockquote>
<p>那么带有推广码的下载地址就是:</p>
<blockquote>
<p><a href="https://itunes.apple.com/bestswifter?at=1001|sTF" target="_blank" rel="external">https://itunes.apple.com/bestswifter?at=1001|sTF</a></p>
</blockquote>
<p>可以看到 HTTP 请求多了一个参数，参数的值 <code>1001|sTF</code> 就是 @im61 同学的推广码， 一旦用户点击了带推广码的地址，@im61 同学就会产生收益。</p>
<h1 id="短链接"><a href="#短链接" class="headerlink" title="短链接"></a>短链接</h1><p>由于 App 的下载地址本来就很长，再加上推广码和活动 ID，非常不利于阅读，因此微博提供了短链接生成器，比如通过微博的短链接生成器，我的长连接 <strong><a href="https://itunes.apple.com/bestswifter?at=1001|sTF" target="_blank" rel="external">https://itunes.apple.com/bestswifter?at=1001|sTF</a></strong> 会被转换成 <strong><a href="http://t.cn/RJ8HDRC" target="_blank" rel="external">http://t.cn/RJ8HDRC</a></strong>:</p>
<p><img src="http://images.bestswifter.com/1487337349.png" alt=""></p>
<p>当你打开短链接的时候，实际上会经过一次 302 跳转，跳到原地址(也就是长连接的地址)。这个技术相当容易实现，因为理论上来说只要用一个字典来存储， 值是长连接，键是短链接(比如最简单的生成方法就是哈希一下)。</p>
<p>这样当你访问 <code>http://t.cn/RJ8HDRC</code> 这个网址时，服务器会拿到 <code>RJ8HDRC</code> 这个键，然后找到对应的值，也就是原始的 iTunes 长连接，再动态拼凑出一个 302 请求即可。302 请求表示页面临时被移动，根据 HTTP 规范，浏览器会重新请求新的临时地址。</p>
<p>我们可以验证一下:</p>
<p><img src="http://images.bestswifter.com/1487337696.png" alt=""></p>
<h1 id="新浪微博是如何作恶的"><a href="#新浪微博是如何作恶的" class="headerlink" title="新浪微博是如何作恶的"></a>新浪微博是如何作恶的</h1><p>首先我们看到红色划线部分，有两个 at 参数，那么服务器以哪个为准呢，答案是不一定。HTTP 协议中并没有规定当 GET 方法的 Query 中出现重复的 key 怎么办，所以通常来说有三种解决方法:</p>
<ol>
<li>以前面的为准，比如 <code>&amp;at=1&amp;at=2</code> 会被服务器当做 <strong><code>&amp;at=1</code></strong> 处理</li>
<li>以后面的为准，比如 <code>&amp;at=1&amp;at=2</code> 会被服务器当做 <strong><code>&amp;at=2</code></strong> 处理</li>
<li>以两者的拼接结果为准，比如 <code>&amp;at=1&amp;at=2</code> 会被服务器当做 <strong><code>&amp;at=[1，2]</code></strong> 处理</li>
</ol>
<p>不同的 Web 服务器实现方法并不一样，比如 PHP 4.4 以后采用的是上述第二种方案。所以我们观察截图可以发现，</p>
<p><strong>微博在原先的 at 字段后面新增了一个重复字段，填上了自己的推广码，一旦用户访问短链接，它返回的 302 重定向实际指向了微博自己的推广链接。</strong></p>
<p>这也证明不管苹果使用的是哪种 Web 服务器，必然都是使用了第二种处理策略。</p>
<p>稍微一动脑子就可以想明白四件事情:</p>
<ol>
<li>微博专门为窃取利益做了调试，它必须搞明白苹果 Web 服务器的处理逻辑。如果采用的是第一种策略，微博就不是在原先的 at 字段后面新增，而是在前面新增。</li>
<li>只要短链接控制权在微博手上，它就可以随意做出修改，当然如果苹果采用了第三种策略，微博是无能为力的(苹果表示这个锅我不背)。</li>
<li>显然并不是所有的链接都会被加上这样的参数，否则有相当多的地址都无法打开，比如我的博客 <code>https://bestswifter.com</code> 生成的短链接再解析回来依然正常。可见微博专门对短链接格式做了判断，如果是以 iTunes 开头才会做手脚。</li>
<li>这也是我觉得最可怕的一点，微博可以针对 iTunes 做专门处理，自然也可以针对其他推广链接做类似处理，至于微博偷走了多少钱，我们不得而知。</li>
</ol>
<p>更让人气愤但是，@im61 同学的微博在 2017 年 2 月 16 日中午一点钟发出，而我写作本文的时间是 17 日晚上 10 点，接近一天半的时间内微博找出各种理由，但就是没有修改的意图。根据我的经验来看，这种策略的添加和删除都是极为容易的，开发者一定提供了良好的接口。</p>
<p>所以我猜测微博的管理层觉得事情还不够大，每拖延一分一秒，又是一大笔收入，年底的财报和股价会更好看。</p>
<p>我没有办法证明时间的准确性，不过希望看到本文的读者还有机会亲自体验一下微博做的恶。</p>
<h1 id="如何防范"><a href="#如何防范" class="headerlink" title="如何防范"></a>如何防范</h1><p>对于微博这种要钱不要脸的行为，如何防范呢，我想大概有两种方法。</p>
<p>第一种方法是利用第三方短链接服务，即先将自己的原始地址转换成安全的短链接，然后再将这个短链接转换成微博的短链接。这是原贴评论中有人提出的方案，我不知道为什么非要使用微博短链接(刚刚测了一下，使用别的短链接生成器似乎也可以)，这里姑且认为是有什么限制吧。</p>
<p>这种方法是一种临时方法，并不保险，因为微博完全可以做一个递归判断，首先检查你的链接访问以后是不是 302，如果是 302 则抓取重定向的地址，直到找到 iTunes 为止。幸好暂时微博还没有这么做，不过为了钱，相信我，微博什么都做得出来。他们可以<a href="http://weibo.com/ttarticle/p/show?id=2309404074275521878291#_0" target="_blank" rel="external">不让你提现，帮你自动发广告微博，乱插时间线</a>。</p>
<h2 id="自建服务器"><a href="#自建服务器" class="headerlink" title="自建服务器"></a>自建服务器</h2><p>最稳妥的方法还是使用自己的服务器，不过评论区中的 HTTPS 加密似乎用处不大。因为 HTTPS 加密只是请求过程加密，而你在发起请求时，必然走的是 GET 方法打开一个 URL，所以自己的推广码必然是明文放在请求头部，比如</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HTTP GET <span class="string">https:</span><span class="comment">//bestswifter.com/promotion=我的推广码</span></div></pre></td></tr></table></figure>
<p>然后我在自己的服务器上返回一个 302 重定向，带上推广码，重定向到 iTunes 上。</p>
<p>在我看来这种做法已经足够安全，因为微博没办法识别自己的 URL 特征，前文说过它只是依赖于 iTunes 开头的链接的识别。当我的域名和 query 键名都被混淆后，微博不可能再对我请求做任何修改，如果还不放心，还可以在服务器上对请求参数自行校验。</p>
<p>总的来说，控制权在自己手上才是最安全。</p>
<h1 id="微博做了哪些恶"><a href="#微博做了哪些恶" class="headerlink" title="微博做了哪些恶"></a>微博做了哪些恶</h1><p>对于微博这样的中间平台来说，它本应该提供更好的安全保护服务，保护用户的合法利益不受侵犯。比如我们目前在做的广告和计费服务，客户端看到的并不是广告的真实地址， 也不会直接向服务器发送扣费请求。客户端能拿到的只是一个加了密的地址，在请求服务器时，一方面服务器对参数解密，进行扣费，另一方面返回 302，重定向到真正的广告地址。</p>
<p>而微博做的确实煞费苦心的调试广告平台存在的 bug，利用自身优势伪造请求数据(类似于 SQL 注入和 XSS 攻击)，并针对不同目标平台做出区分，“优化” 自身收益。当恶行被曝光后，选择是找借口、拖时间而非及时承认错误，抓紧一分一秒从用户手上抢钱。</p>
<p>我想，微博欠无数像 @im61 这样的用户一个道歉。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;这不是意外，不是 bug，是蓄谋已久的阴谋! 不知道阅读完以后，你会不会和我一样心里发寒&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;事件背景&quot;&gt;&lt;a href=&quot;#事件背景&quot; class=&quot;headerlink&quot; title=&quot;事件背景&quot;&gt;&lt;/a&gt;事件背景&lt;
    
    </summary>
    
    
      <category term="HTML" scheme="http://fullstack.blog/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 模块化简析</title>
    <link href="http://fullstack.blog/2017/01/25/JavaScript%20%E6%A8%A1%E5%9D%97%E5%8C%96%E7%AE%80%E8%BF%B0/"/>
    <id>http://fullstack.blog/2017/01/25/JavaScript 模块化简述/</id>
    <published>2017-01-25T03:58:44.000Z</published>
    <updated>2017-01-25T04:02:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于模块化，最直接的表现就是我们写的 <code>require</code> 和 <code>import</code> 关键字，如果查阅相关资料，就一定会遇到 <code>CommonJS</code> 、<code>CMD</code> <code>AMD</code> 这些名词，以及 <code>RequireJS</code>、<code>SeaJS</code> 等陌生框架。比如 <a href="http://seajs.org/docs/" target="_blank" rel="external">SeaJS 的官网</a> 这样描述自己: “简单友好的模块定义规范，Sea.js 遵循 CMD 规范。自然直观的代码组织方式，依赖的自动加载……”</p>
<p>作为前端新手，我表示实在是一脸懵逼，理解不能。按照我一贯的风格，介绍一个东西之前总得解释一下为什么需要这个东西。</p>
<h1 id="JavaScript-基础"><a href="#JavaScript-基础" class="headerlink" title="JavaScript 基础"></a>JavaScript 基础</h1><p>做客户端的同学对 OC 的 <code>#import &quot;classname&quot;</code>、Swift 的 Module 以及文件修饰符 和 Java 的 <code>import package+class</code> 模式应该都不陌生。我们习惯了引用一个文件就是引用一个类的模式。然而在 JavaScript 这种动态语言中，事情又有一些变化，举个例子说明:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"hello"</span>&gt;</span> Hello Wrold <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"onPress()"</span> <span class="attr">value</span>=<span class="string">"Click me"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// index.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onPress</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'hello'</span>);</div><div class="line">    p.innerHTML = <span class="string">'Hello bestswifter'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>HTML 中的 <code>&lt;script&gt;</code> 标签可以理解为 import，这样按钮的 <code>onclick</code> 事件就可以调用定义在 <code>index.js</code> 中的 <code>onPress</code> 函数了。</p>
<p>假设随着项目的发展，我们发现点击后的文字需要动态生成，并且由别的 JS 文件生成，那么简单的 <code>index.js</code> 就无法胜任了。我们假设生成的内容定义在 <code>math.js</code> 文件中:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// math.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>按照客户端的思维，此时的 <code>index.js</code> 文件应该这样写:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// index.js</span></div><div class="line"><span class="keyword">import</span> <span class="string">"math.js"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onPress</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'hello'</span>);</div><div class="line">    p.innerHTML = add(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很不幸，JavaScript 并不支持 import 这种写法，也就是说在一个 JS 文件中根本无法引用别的 JS 文件中的方法。正确的解决方案是在 <code>index.js</code> 中直接调用 <code>add</code> 方法，同时在 <code>index.html</code> 中引用 <code>math.js</code>:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"math.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"hello"</span>&gt;</span> Hello Wrold <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"onPress()"</span> <span class="attr">value</span>=<span class="string">"Click me"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// index.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onPress</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'hello'</span>);</div><div class="line">    p.innerHTML = add(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到这种写法并不优雅， <code>index.js</code> 对别的 JS 文件中的内容并没有控制权，能否调用到 <code>add</code> 方法完全取决于使用自己的 HTML 文件有没有正确引用别的 JS 文件。</p>
<h1 id="初步模块化"><a href="#初步模块化" class="headerlink" title="初步模块化"></a>初步模块化</h1><p>刚刚所说的痛点其实可以分为两种:</p>
<ol>
<li>index.js 无法 import，依赖于 HTML 的引用</li>
<li>index.js 中无法对 add 方法的来源做区分，缺少命名空间的概念</li>
</ol>
<p>第一个问题留在后面解答，我们先着手解决第二个问题，比如先把函数放到一个对象中，这样我们可以暴露一个对象，让使用者调用这个对象的多个方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//index.js </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onPress</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'hello'</span>);</div><div class="line">    p.innerHTML = math.add(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//math.js</span></div><div class="line"><span class="keyword">var</span> math = &#123;</div><div class="line">    <span class="attr">base</span>: <span class="number">0</span>,</div><div class="line">    <span class="attr">add</span>: <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> a + b + base;</div><div class="line">    &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看到在 <code>index.js</code> 中已经可以指定一个简易版的命名空间了(也就是 math)。但目前还有一个小问题，比如 base 这个属性会被暴露给外界，也可以被修改。所以更好的方式是将 <code>math</code> 定义在一个闭包里，从而隐藏内部属性:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// math.js</span></div><div class="line"><span class="keyword">var</span> math = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> base = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">add</span>: <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> a + b + base;</div><div class="line">        &#125;,</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>到目前为止，我们实现了模块的定义和使用。不过模块化的一大精髓在于命名空间，也就是说我们希望自己的 <code>math</code> 模块不是全局的，而是按需导入，这样一来，即使多个文件暴露同名对象也不会出问题。就像 node.js 中那样，需要暴露的模块定义自己的 export 内容，然后调用方使用 require 方法。</p>
<p>其实可以简单模拟一下 node.js 的工作方式，通过增加一个中间层来解决: 首先定义一个全局变量:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// global.js</span></div><div class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</div><div class="line">    <span class="attr">exports</span>: &#123;&#125;, <span class="comment">// 用来存储所有暴露的内容</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后在 <code>math.js</code> 中暴露对象:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> math = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> base = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">add</span>: <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> a + b + base;</div><div class="line">        &#125;,</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports.math = math;</div></pre></td></tr></table></figure>
<p>使用者 <code>index.js</code> 现在应该是:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> math = <span class="built_in">module</span>.exports.math;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onPress</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'hello'</span>);</div><div class="line">    <span class="comment">// math</span></div><div class="line">    p.innerHTML = math.add(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="现有模块化方案"><a href="#现有模块化方案" class="headerlink" title="现有模块化方案"></a>现有模块化方案</h1><p>上述简单的模块化方式有一些小问题。首先，<code>index.js</code> 必须严格依赖于 <code>math.js</code> 执行，因为只有 <code>math.js</code> 执行完才会向全局的 <code>module.export</code> 中注册自己。这就要求开发者必须手动管理 js 文件的加载顺序。随着项目越来越大，依赖的维护会变得越来越复杂。</p>
<p>其次，由于加载 JS 文件时，浏览器会停止渲染网页，因此我们还需要 JS 文件的异步按需加载。</p>
<p>最后一个问题是，之前给出的简化版模块化方案并没有解决模块的命名空间，相同的导出依旧会替换掉之前的内容，而解决方案则是维护一个 “文件路径 &lt;–&gt; 导出内容” 的表，并且根据文件路径加载。</p>
<p>基于上述需求，市场上出现了很多套模块化方案。为啥会有多套标准呢，实际上还是由前端的特性导致的。由于缺乏一个统一的标准，所以很多情况下大家做事的时候都是靠约定，就比如上述的 export 和 require。如果代码的提供者把导出内容存储在 <code>module.exports</code> 里，而使用者读取的是 <code>module.export</code>，那自然是徒劳的。不仅如此，各个规范的实现方式、使用场景也不尽相同。</p>
<h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>比较知名的规范有 CommonJS、AMD 和 CMD。而知名框架 Node.js、RequireJS 和 Seajs 分别实现了上述规范。</p>
<p>最早的规范是 CommonJS，Node.js 使用了这一规范。这一规范和我们之前的做法比较类似，是同步加载 JS 脚本。这么做在服务端毫无问题，因为文件都存在磁盘上，然而浏览器的特性决定了 JS 脚本需要异步加载，否则就会失去响应，因此 CommonJS 规范无法直接在浏览器中使用。</p>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>浏览器端著名的模块管理工具 Require.js 的做法是异步加载，通过 Webworker 的 <code>importScripts(url);</code> 函数加载 JS 脚本，然后执行当初注册的回调。Require.js 的写法是:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'myModule1'</span>, <span class="string">'myModule2'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">m1, m2</span>)</span>&#123;</div><div class="line">    <span class="comment">// 主回调逻辑</span></div><div class="line">    m1.printName();</div><div class="line">    m2.printName();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>由于这两个模块是异步下载，因此哪个模块先被下载、执行并不确定，但可以肯定的是主回调一定在所有依赖都被加载完成后才执行。</p>
<p>Require.js 的这种写法也被称为前置加载，在写主逻辑之前必须指定所有的依赖，同时这些依赖也会立刻被异步加载。</p>
<p>由 Require.js 引申出来的规范被称为 AMD(Asynchronous Module Definition)。</p>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>另一种优秀的模块管理工具是 Sea.js，它的写法是:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">'foo'</span>); <span class="comment">// 同步</span></div><div class="line">    foo.add(<span class="number">1</span>, <span class="number">2</span>); </div><div class="line">    ...</div><div class="line">    require.async(<span class="string">'math'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">math</span>) </span>&#123; <span class="comment">// 异步</span></div><div class="line">        math.add(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Sea.js 也被称为就近加载，从它的写法上可以很明显的看到和 Require.js 的不同。我们可以在需要用到依赖的时候才申明。</p>
<p>Sea.js 遇到依赖后只会去下载 JS 文件，并不会执行，而是等到所有被依赖的 JS 脚本都下载完以后，才从头开始执行主逻辑。因此被依赖模块的执行顺序和书写顺序完全一致。</p>
<p>由 Sea.js 引申出来的规范被称为 CMD(Common Module Definition)。</p>
<h1 id="ES-6-模块化"><a href="#ES-6-模块化" class="headerlink" title="ES 6 模块化"></a>ES 6 模块化</h1><p>在 ES6 中，我们使用 <code>export</code> 关键字来导出模块，使用 <code>import</code> 关键字引用模块。需要说明的是，ES 6 的这套标准和目前的标准没有直接关系，目前也很少有 JS 引擎能直接支持。因此 Babel 的做法实际上是将不被支持的 <code>import</code> 翻译成目前已被支持的 <code>require</code>。</p>
<p>尽管目前使用 <code>import</code> 和 <code>require</code> 的区别不大(本质上是一回事)，但依然强烈推荐使用 <code>import</code> 关键字，因为一旦 JS 引擎能够解析 ES 6 的 <code>import</code> 关键字，整个实现方式就会和目前发生比较大的变化。如果目前就开始使用 <code>import</code> 关键字，将来代码的改动会非常小。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>以上内容大部分都不是我的思考结果，我只是对已有的文章做了一下实际操作和归纳总结，感谢各位前辈的优秀文章:</p>
<ol>
<li><a href="http://stackoverflow.com/questions/3244361/can-i-access-variables-from-another-file" target="_blank" rel="external">Can I access variables from another file?</a></li>
<li><a href="https://segmentfault.com/a/1190000000492678" target="_blank" rel="external">浅谈 JavaScript 模块化编程</a></li>
<li><a href="http://www.cnblogs.com/dolphinX/p/4381855.html" target="_blank" rel="external">前端模块化</a></li>
<li><a href="https://segmentfault.com/a/1190000000733959#articleHeader6" target="_blank" rel="external">详解JavaScript模块化开发</a></li>
<li><a href="http://www.html-js.com/article/AngularJs-requireJS-the-realization-principle-of-1" target="_blank" rel="external">requireJS实现原理研究</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank" rel="external">Javascript模块化编程（一）：模块的写法</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html" target="_blank" rel="external">Javascript模块化编程（二）：AMD规范</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/05/commonjs-in-browser.html" target="_blank" rel="external">浏览器加载 CommonJS 模块的原理与实现</a></li>
<li><a href="http://imweb.io/topic/582293894067ce9726778be9" target="_blank" rel="external">Node中没搞明白require和import，你会被坑的很惨</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;关于模块化，最直接的表现就是我们写的 &lt;code&gt;require&lt;/code&gt; 和 &lt;code&gt;import&lt;/code&gt; 关键字，如果查阅
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://fullstack.blog/tags/JavaScript/"/>
    
      <category term="前端" scheme="http://fullstack.blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>我的 2016 年总结</title>
    <link href="http://fullstack.blog/2016/12/31/%E6%88%91%E7%9A%84-2016-%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>http://fullstack.blog/2016/12/31/我的-2016-年总结/</id>
    <published>2016-12-31T15:47:39.000Z</published>
    <updated>2016-12-31T12:38:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>时光飞逝，一转眼已经是一年过去了， 去年的今天我写下了第一篇年度总结：<a href="http://www.jianshu.com/p/fe529a7e83a0" target="_blank" rel="external">一个普通iOS开发者的2015大总结</a>。在写作那篇文章之前，我觉得一年前的自己完全是一个傻逼；今天重读一遍以后，我感觉一年前的自己也非常傻逼。在写下这一年总结的同时，我也希望明年的自己在回顾这篇文章的时候，可以发出不屑的鄙视。</p>
<p>实际上我认为:</p>
<blockquote>
<p>刚开始学习的前五年是发展最快的五年，每一年都应该感觉到自己在过去的一年中发生了天翻地覆的变化。</p>
</blockquote>
<p>本文既然是总结， 自然是充满了大量的主观看法。如果读者不认可其中的某些观点，大可呵呵一笑，抛之脑后，切勿较真，做无意义的争论。</p>
<h1 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h1><p>我从元旦后就开始着手准备春招。首先翻译完了 <a href="http://www.jianshu.com/p/18744b078508" target="_blank" rel="external">Advanced Swift</a>(盗版可耻)，这是自己第一次完整的阅读完一本英语书籍，学到了非常多的知识，有英语方面的，也有 Swift 方面的，随后自己尝试着用 Swift 开发了一个小 app。虽然后续由于工作原因没有能继续接触 Swift，不过它的优雅、简洁还是深深的吸引了我。希望 Swift 4.0 发布后能够解决 ABI 稳定问题。</p>
<p>如果 Xcode 对 Swift 的支持能更友好，业内再提出成熟的动态化方案，我相信 Swift 会有更光明的未来和使用场景。</p>
<h2 id="Swift-与后端开发"><a href="#Swift-与后端开发" class="headerlink" title="Swift 与后端开发"></a>Swift 与后端开发</h2><p>随着 Swift 的愈发成熟，业内出现了很多比较成熟的后端开发框架， 比如 <a href="http://perfect.org/" target="_blank" rel="external">perfect</a>、<a href="https://vapor.codes/" target="_blank" rel="external">vapor</a> 等。然而我本人并不看好这一领域，主要是从编程语言和程序员两个角度出发。</p>
<p>理论上来说，任何可以调用 socket 接口处理网络请求的语言都可以用来做后端开发，然而对于 Swift 来说，除了处理网络请求以外，一个优秀的 API 也至关重要。不管是 HTTP 协议的解析，还是字符串、栈、时间等常用数据结构的操作，都不方便由做业务的程序员去手动解析。</p>
<p>框架的使用者应该关注业务开发，而不是通用业务的处理。比较遗憾的是，Swift 目前在这一方面做的还不够好，很多重要的操作缺乏语言层面的支持，导致开发者造轮子的成本过高。不过 Swift 已经成立了官方小组，致力于解决这一问题。</p>
<p>考虑到 Swift 还不是个非常成熟的语言，目前还在快速迭代。相比于语言本身，我认为人的问题才是阻碍 Swift 在服务端发力的最大原因。不管是现有哪种用来进行后端开发的语言，都有它本身的卖点。比如 Java 的高效(运行时效率)、稳定、全面，或者 PHP、Ruby 的语法简洁，易上手，还是 GO 的高并发，亦或是 Node.js 的全栈，都能在某个特定场景下派上用场。</p>
<p>目前的 Swift 似乎还没有找到属于自己的舞台，由于绝大多数开发者都是 iOS 开发者，他们并不适合转向服务端开发，这就意味着 Swift 能写 iOS 毫无吸引力(参考一下 JS 能做哪些事)。而对于具有服务的开发经验的开发者来说，Swift 又没有吸引他们切换过去的理由。</p>
<h1 id="准备春招"><a href="#准备春招" class="headerlink" title="准备春招"></a>准备春招</h1><p>一不小心就扯远了， 话题回到总结上来。完成了 Swift 学习的收尾工作后，我的精力主要放在春招上。由于大二下学期积累了三个月的实习经验，这一阶段的目的主要是夯实基础。因此重点读了两本书，《图解 TCP/IP》(<a href="http://www.jianshu.com/notebooks/3276500/latest" target="_blank" rel="external">总结</a>)、《剑指 Offer》。</p>
<h2 id="图解-TCP-IP"><a href="#图解-TCP-IP" class="headerlink" title="图解 TCP/IP"></a>图解 TCP/IP</h2><p>这本书主要是讲解了 TCP/IP 四层协议栈(或者分得更细点就是七层)，通过一些插图和实际例子来解释枯燥的概念。我认为这是一本不可多得的好书，尤其适合新手入门。不过，如果想精通网络层，还是建议买 《TCP/IP 详解》和 《HTTP 权威指南》或者直接查阅 RFC 协议。</p>
<p>不过在准备面试，或者新手入门时，我觉得非常有必要通过一本简短的书籍来形成大致的知识框架和，这样后续才能有针对性的学习总结，对自己的知识框架进行各种修修补补。</p>
<h2 id="剑指-Offer"><a href="#剑指-Offer" class="headerlink" title="剑指 Offer"></a>剑指 Offer</h2><p>这本书相当应试，不过也必须承认它概括了绝大多数常见的算法面试题。如果我们把面试看做是企业对应聘者的能力筛选和鉴定而不是刁难，那么从一定角度来说，也可以证明这本书涵盖了绝大多数常见的场景和算法。</p>
<p>如果不想只是纸上谈兵，还可以去 <a href="https://leetcode.com/problemset/algorithms/" target="_blank" rel="external">Leetcode</a> 上找找书中问题对应的题目，参考全世界大牛的精妙解法也会受益匪浅。</p>
<h2 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h2><p>作为一名 iOS 开发者，iOS 开发是我的本业，除了准备计算机基础知识外，我也学习了很多 iOS 开发的知识。以上的详细内容都总结在 《<a href="http://www.jianshu.com/p/ee15c1cf9c16" target="_blank" rel="external">让 BAT 的 Offer 不再难拿</a>》，就不赘述了。</p>
<h1 id="入职"><a href="#入职" class="headerlink" title="入职"></a>入职</h1><p>春招顺利的拿到了百度贴吧的 offer，入职以后受益匪浅。在善品、权叔等老司机的带领下，我有一种乡下人进城的兴奋感，感觉自己的成长速度非常快。</p>
<h2 id="MVC-与-UITableview"><a href="#MVC-与-UITableview" class="headerlink" title="MVC 与 UITableview"></a>MVC 与 UITableview</h2><p><code>UITableview</code> 是 iOS 开发中最常见的 UI 控件之一，但是想写好一个 <code>UITableview</code>，做到封装、解耦，并与网络请求良好的结合起来并不容易。我花了一定时间学习了贴吧以前的框架，对其做了一些简化和整理，总结在这里: <a href="http://www.jianshu.com/p/504c61a9dc82" target="_blank" rel="external">如何写好一个UITableView</a>。框架没有最优与全能，适合团队业务的就是最好的，所以这套框架主要是为了贴吧业务打造，但也有自己的不足，读者切不可照搬全抄。</p>
<h2 id="高效使用-Mac"><a href="#高效使用-Mac" class="headerlink" title="高效使用 Mac"></a>高效使用 Mac</h2><p>我比较看重开发效率，因为我认为开发者应该把宝贵的时间花费在工作本身，而不是与之无关的杂事上。并不耗时的高频操作和比较耗时的中频操作都应该使用快捷键或自动化工具对其进行简化，不过也切忌矫枉过正。对非常低频的操作进行自动化或者仅仅是为了装逼，往往会浪费大量不必要的时间，反而适得其反。</p>
<p>我总结了<a href="http://www.jianshu.com/p/2b072b206c90" target="_blank" rel="external">一篇文章</a> 并做了<a href="http://m.quzhiboapp.com/#!/intro/193" target="_blank" rel="external">一次直播</a>，主要涉及全局快捷键、Xcode、Vim、Chrome、Vimium、Git、Zsh、Alfred、Zsh、Emacs 等. 强烈建议对此还不了解的读者收看直播回放。</p>
<h1 id="iOS-深入"><a href="#iOS-深入" class="headerlink" title="iOS 深入"></a>iOS 深入</h1><p>在工作之余，我对 iOS 领域的一些常用知识做了深入学习。</p>
<h2 id="GCD-与多线程"><a href="#GCD-与多线程" class="headerlink" title="GCD 与多线程"></a>GCD 与多线程</h2><p>虽然去年就复习过类似的话题，但仅仅是停留在总结整理的层面，说白了就是把所有 API 熟悉了一遍。这次学习时，我阅读了 GCD 的源码，从而从更深层次理解了 GCD 的实现原理，总结了一篇文章: <a href="http://www.jianshu.com/p/06a18323d9d2" target="_blank" rel="external">深入理解 GCD</a>。</p>
<h2 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h2><p>最初接触 runloop 是听了孙源大神的分享，随着学习的深入，发现还是有必要对 Runloop 进行深入的理解。不过 Runloop 虽然重要，但实际使用中接触得并不太多，除了常见的 NSTimer 触发问题外，也就是性能检测时会与之打交道。所以它源码阅读的必要性并不是太高，我觉得只要对 Runloop 的基本概念和工作原理有所涉猎即可。遇到实际问题时可以查阅 ibireme 的 <a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a>。</p>
<p>我写了一篇: <a href="http://www.jianshu.com/p/10121d699c32" target="_blank" rel="external">深入研究 Runloop 与线程保活</a> 作为自己的学习总结。</p>
<h2 id="线程调用栈"><a href="#线程调用栈" class="headerlink" title="线程调用栈"></a>线程调用栈</h2><p>上一节谈到了利用 runloop 检测主线程的卡顿。为了找到性能瓶颈，也就是优化点，我们需要在卡顿发生时得到实时的线程调用栈。这就意味着一切依赖于线程层面的操作都会破坏原来线程的调用栈。在尝试使用信号无果后，最终我选择了参考第三方开源框架，直接利用 C 语言解析函数调用栈。具体总结参考: <a href="http://www.jianshu.com/p/7e4c7b94ca36" target="_blank" rel="external">获取任意线程调用栈的那些事</a>。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>iOS 中有很多锁，从最底层的互斥锁、信号量到顶层的 <code>@synchronized</code>，应有尽有。虽然我实际使用经验并不多，但还是研究了一下他们的实现原理和性能优劣: <a href="http://www.jianshu.com/p/8781ff49e05b" target="_blank" rel="external">深入理解 iOS 开发中的锁</a>。随着对多线程在理论和实践上的进一步接触，我相信还会有更具深度的总结面世。</p>
<h2 id="Xcode-项目配置"><a href="#Xcode-项目配置" class="headerlink" title="Xcode 项目配置"></a>Xcode 项目配置</h2><p>出于对 Cocoapods 工作原理的兴趣，我前段时间手动模拟了它的工作过程(自动化是通过 ruby 脚本完成的，相对而言重要性低很多)。在这一过程中，更重要的是对编译、链接、Xcode 工程配置的理解。由于时间原因，目前还没有形成总结性文档。</p>
<h1 id="全栈"><a href="#全栈" class="headerlink" title="全栈"></a>全栈</h1><p>相比于 iOS 方面的钻研，2016 年最让我感到激动和收益满满的是横向的拓展。关于为什么会选择横向发展路线，在我的 <a href="http://fullstack.blog/2016/11/18/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/">新的开始</a> 一文中已经有了详细的阐述。</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表是常见的数据结构，但是很多人对他的掌握都非常浅显。曾经问过很多人一个很简单的问题:“为什么很多哈希表的实现中，数组的长度都是 2 的整数次幂？”。根据我的观察，能答出这个问题的人寥寥无几，有很多看上去很正确的废话，其实恰恰说明了大多数人多哈希表的理解还不够深入。</p>
<p>除此以外，不同的语言和框架(OC、Java、Redis、一致性哈希) 对哈希表的实现都各不相同，他们的取舍恰恰说明不同场景下我们关注的指标并不一致，必须舍弃一些无关紧要的功能点，来换取主要功能的性能的大幅度提高。具体对比请参考: <a href="http://www.jianshu.com/p/138ccbc75803" target="_blank" rel="external">深入理解哈希表</a>。</p>
<h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><p>市面上有很多介绍 Node.js  的优秀文章和书籍，作为一个不懂 Node.js 的小白，其实我只关系以下几个问题:</p>
<ol>
<li>为什么要从现有的后端开发框架切换到 Node.js？</li>
<li>Node.js 是银弹么，还是有特别适合自己的使用场景？</li>
<li>Node.js 的事件循环是如何工作的？有什么好处？</li>
<li>Node.js 是异步单线程的， 那么如何最大程度的利用多核 CPU 的所有性能？</li>
</ol>
<p>作为上述问题的回答，我总结了 <a href="http://www.jianshu.com/p/59e59acde382" target="_blank" rel="external">为什么要用 Node.js</a>。</p>
<h2 id="前后端分离与前端开发流程"><a href="#前后端分离与前端开发流程" class="headerlink" title="前后端分离与前端开发流程"></a>前后端分离与前端开发流程</h2><p>在学习 Node.js 的过程中，我接触到了一个新名词:前后端分离。对于客户端开发者来说，前后端分离是一件天经地义的事情。前端界面是由编译后的代码生成的，相对来说比较固定。前后端的主要交流方式是 JSON/protobuf 等数据交换格式。</p>
<p>然而对于前端开发者来说，事情远远不止这么简单。由于前端的 UI 样式完全由 Server 下发，所以很容易就产生了前后端业务和代码的耦合。所以前后端分离说的就是前端开发和后端开发如何进行解耦和数据交互，详见 <a href="http://www.jianshu.com/p/36a3c79cd18f" target="_blank" rel="external">移动端开发者眼中的前端开发流程变迁与前后端分离</a>。</p>
<h2 id="利用-JS-等脚本语言实现客户端热更新"><a href="#利用-JS-等脚本语言实现客户端热更新" class="headerlink" title="利用 JS 等脚本语言实现客户端热更新"></a>利用 JS 等脚本语言实现客户端热更新</h2><p>不管是 JSPatch 还是 React Native，它们都能做到客户端的热更新，甚至无需通过 AppStore 即可发一个新版本。它们之所以能够做到客户端热更新，主要是依赖了客户端对 JavaScript 的支持以及 iOS 自身基于 runtime 的元编程技术。首先，利用 JSON 传递信息的区别在于它仅有描述信息，却无法携带逻辑信息。</p>
<p>通过官方认可的 JavaScriptCore 框架，我们可以运行一段 JavaScript 代码并获取运行结果。通过对运行结果的解析，我们可以利用 runtime 动态的调用本地预定义好的方法，从而实现了动态化。</p>
<p>React Native 的本质是一个 Hybrid 桥。它与 React 具有相同的 API，为了实现相同的效果，客户端会调用本地的方法(比如 <code>addSubview</code> 等)。详细请参考: <a href="http://www.jianshu.com/p/978c4bd3a759" target="_blank" rel="external">React Native 从入门到原理</a>。</p>
<h2 id="脚本语言"><a href="#脚本语言" class="headerlink" title="脚本语言"></a>脚本语言</h2><p>一般来说我们认为脚本语言就是没有编译器的、由解释器动态解释的语言。它通常具有弱类型、格式简单、开发效率高等优点，但是作为代价，用脚本语言来开发大型项目会遇到诸多问题。比如性能、调试等等，毕竟它们原本只是用来快速完成某个小的需求。</p>
<p>我最先接触的是 python，我使用 python 编写了 alfred 的一个 workflow，后来在 leader 的带领下实现了一个可以 hook 请求和返回结果的 http 代理服务器。有了实战的机会，也就成功脱离了 hello world 的水平了。</p>
<p>同时我也简单接触了 Ruby。光从脚本语言的角度来看，它和 Python 的作用相仿。不过很多领域特定语言(DSL) 都选择了 Ruby 来实现， 比如我们常用的 cocoapods 中的 Podfile，如果不说，可能只有少数人能意识到这其实是一段标准的 Ruby 代码。</p>
<p>之所以选择用 Ruby 来实现，是因为它的语法可读性更好，看上去就像一段普通的描述性文字。详细的分析可以参考: <a href="http://www.jianshu.com/p/2434e62158d1" target="_blank" rel="external">白话 Ruby 与 DSL 以及在 iOS 开发中的运用</a>。</p>
<p>严格意义上来说，Shell 脚本才是脚本语言的鼻祖，它提供了非常多常用的工具，比如 <code>awk</code> 和 <code>sed</code> 两大文本处理利器。如果需要对文字、文件目录做简单的逻辑操作，应该优先使用 Shell 而不是其他脚本语言。</p>
<p>不同的脚本语言往往是为了解决不同领域的问题而诞生的(虽然它们也可以解决其他问题)，遇到问题的时候应该选择最合适、优雅的解决方案，而不是总想着复用当前技术栈。俗话说:“如果你只有锤头，那看什么都是钉子”。</p>
<h2 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h2><p>Swift 诞生后就一直宣传自己面向接口编程的特性，然而在我看来它不过是一种多继承的实现方案。且不谈继承的缺点以及在它和组合之间如何选择，光是多继承，就有很多种实现。比如 C++、Python、Java、Ruby 都有各自的实现。其中有优雅的，也有相对来说比较暴力直接的。</p>
<p>我个人更喜欢 Java 对多继承的实现，与之相比，Swift 的面向接口编程还有一些可以提高的地方。详细可以参考: <a href="http://www.jianshu.com/p/fc105512bf40" target="_blank" rel="external">从 Swift 的面向协议编程说开去</a></p>
<h2 id="安卓"><a href="#安卓" class="headerlink" title="安卓"></a>安卓</h2><p>从 12 月份开始，由于安卓同事返校上课，我有机会开始接触安卓开发。目前还停留在小白阶段，只能根据前人的代码抄抄改改。安卓的学习主要还是 API 的积累和 Java 语言的学习，希望能在明年总结出更多关于安卓的优秀文章。</p>
<h1 id="我的-2016"><a href="#我的-2016" class="headerlink" title="我的 2016"></a>我的 2016</h1><p>对于把好好的年终总结写成了博客摘要我是很不满意的，如果用一个词来总结我的 2016 年，我想那毫无疑问就是:“<strong>拓宽</strong>”。虽然 iOS  还没有达到炉火纯青的地步，但我还是义无反顾的开始了横向拓宽。我相信一个人才的最大价值，不是做好某一个具体的小需求(这是前提)，而是站在更高的角度做更大的事。</p>
<p>16 年技术栈拓展中，最大的三个收获应该是前端、Python 和安卓。然而考虑到与工作相结合，我想前端技术暂时可以放一放，重点学习 Python 和安卓也许会对 KPI 更加有利。</p>
<p>当然，好的书还是要读的。博客可以解释清楚某一个问题，而好书可以解释清楚某一个领域。在 Server 方面，李智慧的 《大型网站技术架构》 可以算作一本非常优秀的入门版书籍，介绍了诸多常见的属于和概念。而《计算机程序的构造和解释》(SICP) 作为 MIT 几十年来的教科书，是一本非常经典的介绍函数式编程的书籍。以上两本书推荐给感兴趣的读者。</p>
<p>过去的这一年成长了很多，从简书、微博几十个粉丝的小菜鸟，到几千粉丝的小 V，一路走来收获满满。不过我逐渐意识到越是大型的平台，普通用户的质量就越接近于行业平均水平。因此粉丝数、喜欢数并不值得参考，而且很多交流其实是浪费时间。因此在新的一年中我会减少社交平台上的互动，把有限的精力投入到线下的生活、工作、学习中去。</p>
<h1 id="2017-年的计划"><a href="#2017-年的计划" class="headerlink" title="2017 年的计划"></a>2017 年的计划</h1><p>在去年的年终总结里，我列出了五点计划:</p>
<ol>
<li>继续翻译优秀的英文文章。这一点做的不太好，虽然有幸加入了 SwiftGG 并翻译了一些 Swift 文章，但是总的来说数量还不够。不过考虑到还有非常多要做的事，翻译文章的性价比似乎就不太高了，所以暂时搁浅。</li>
<li>阅读优秀的博文。objc.cn 的文章在带着读，由于掌握了 Google 搜索， 所以再也不会像去年一样看 CSDN 了，从这一点来说，第二个目标算是圆满完成。</li>
<li>技术与基础。今年学习了 GCD、Runloop、Runtime、锁、Cocoapods、React Native 等技术，算是加深了技术深度，</li>
<li>读书。读完了 《图解 TCP/IP 》、《剑指 Offer》、《大型网站技术架构》、《计算机程序的构造与解释》，双十一还买(挖)了不少书(坑)。</li>
<li>实习。在贴吧和凤巢的日子里，小组里的各位同事一直在帮助我成长，我的每一丝进步都要感谢他们的帮助。</li>
</ol>
<p>总的来说 16 年的计划圆满完成了，在新的一年里我为自己制定了几个小目标:</p>
<ol>
<li>业务: 也许业务没有技术重要，但是没有业务的积累，再厉害的技术也只会浪费时间，甚至带来负面作用。踏入工作岗位后，我希望在 2017 年更加深入的理解团队业务，更好的融入团队的交流协作中。</li>
<li>读书: 双十一买了十几本书，目前看来优先级最高的是《七周七并发模型》和 《改善  Python 程序的 91 个建议》，如果有空的话 《Java 编程思想》和 《Effective Java》、《Android 开发艺术探索》也在计划中。</li>
<li>技术: 所谓的全栈工程师，或者 T 型人才并不是全干工程师，每一门技术必须掌握到一定深度。因此在跨界时切忌自我麻痹，不能总以“我是新手”为理由来安慰自己。我希望在新的一年里在 Python 和 Android 方面达到一定深度，以工作为标准来要求自己。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时光飞逝，一转眼已经是一年过去了， 去年的今天我写下了第一篇年度总结：&lt;a href=&quot;http://www.jianshu.com/p/fe529a7e83a0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一个普通iOS开发者的2015大总结&lt;/a&gt;。
    
    </summary>
    
    
      <category term="总结分享" scheme="http://fullstack.blog/tags/%E6%80%BB%E7%BB%93%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 代理服务器技术选型之旅</title>
    <link href="http://fullstack.blog/2016/12/30/HTTP-%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E4%B9%8B%E6%97%85/"/>
    <id>http://fullstack.blog/2016/12/30/HTTP-代理服务器技术选型之旅/</id>
    <published>2016-12-30T11:10:14.000Z</published>
    <updated>2016-12-30T11:10:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>好久不写博客了，在元旦到来前水一篇文章，聊聊我在实现代理服务器的过程中遇到的一些坑，同时祝各位读者新年快乐。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>长期以来，贴吧开发人员多，业务耦合大，需求变化频繁，因此容易产生 bug。而我所负责的广告相关业务，和 UI 密切相关，一旦因为某种原因(甚至是被别人改了代码)产生了 bug，必然大幅度影响广告收入。</p>
<p>解决问题的一种方法在于频繁的测试，既然避免不了代码层面的耦合，那总是可以通过定时的检查来避免问题。所以我们维护了一组核心 case，密切关注最核心的功能。选择核心 case 实际上是在覆盖面和测试成本之间的权衡，然而多个 case 有不同的测试步骤，测试效率始终难以提高。</p>
<p>因此，我们的目标是建立一个代理服务器，<strong>能够在运行时把任何包(包括线上包)的数据改成我希望的样子</strong>。换句话说，这个代理服务器也可以理解为一个私服，它能够获得客户端的请求数据并作出修改，也可以获得服务端的响应数据并做修改。</p>
<h1 id="代理服务器工作模型"><a href="#代理服务器工作模型" class="headerlink" title="代理服务器工作模型"></a>代理服务器工作模型</h1><p>在早期版本中，我们选择了简单的 HTTP 协议。这种选择对技术的要求最低，我们自己实现了一个代理服务器，开启 socket，监听端口，然后将客户端的请求发送给服务器，再把服务器的返回数据传回客户端。这种模式也被称为:“中间人模式”(MITM: Man In The Middle)。</p>
<p>虽然道理很简单，但实现起来还是有些地方要注意。首先，当 socket 接受数据后，应该新开一个进程/线程 进行处理。既然涉及到新的进程/线程，就一定要注意它的释放时机，否则会导致内存无限制增加。</p>
<p>其次，对于 <code>socket</code> 来说，它并没有等待函数，也就是说我无从得知何时有数据可读，因此这个艰巨的任务就交给了 <code>select</code>。我们把需要监听的 socket 对象作为参数传入其中，函数会一直阻塞，直到有可读、可写的对象，或者达到超时时间。</p>
<p><code>Keep-Alive</code> 字段可以复用 TCP 连接，是一种常见的 HTTP 协议的优化方式，在 HTTP 1.1 中已经是默认选项。填写这个字段后，Server 返回的数据可能是分批次的，这样能够改善用户体验，但也会增加代理服务器的实现难度。所以代理服务器在作为客户端，向真正服务器请求数据时，应该删除这个字段。</p>
<p>由于整套流程都是自己实现，因此可以比较容易的 HOOK 住上下行数据并做修改。只有注意在接收到全部数据后再做修改即，整个流程可以用下图简单表示:</p>
<p><img src="https://o8ouygf5v.qnssl.com/1483087878.png" alt="代理服务器的工作模式"></p>
<p>当时做完这一套东西以后，我在团队内部做了一次分享， 感兴趣的读者可以去 <a href="http://images.bestswifter.com/Proxy%202.key" target="_blank" rel="external">http://images.bestswifter.com/Proxy%202.key</a> 下载 PPT。</p>
<h1 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h1><h2 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h2><p>由于长连接基于 TCP，不用每次新建连接，也省略了不必要的 HTTP 报文头部，效率明显优于 HTTP。所以各大公司基本上选择了长连接作为实际生产环境下的连接方式。然而由于不熟悉 WebSocket 协议，并且我们依然支持短连接，所以代理服务器最终选择了 HTTP 协议。</p>
<p>要想实现这一点， 就得在应用启动时，模拟后台向客户端发送一段控制信息，强制客户端选择 HTTP 请求。这样一来，即使是线上包也可以走代理服务器。</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>由于苹果强制要求使用 HTTPS，虽然已经延期，但也是明年的趋势。考虑到后续的使用，我们决定对之前实现的代理服务器进行升级。由于 HTTPS 涉及到请求协议的解析，以及加密解密和证书管理，上述自研方案很难 hold 住。经过一番调研，最后选择了一个比较知名的开源库 <a href="https://github.com/mitmproxy/mitmproxy" target="_blank" rel="external">mitmproxy</a>。</p>
<h1 id="Mitmproxy"><a href="#Mitmproxy" class="headerlink" title="Mitmproxy"></a>Mitmproxy</h1><p>选择这个库最主要的理由是它直接支持 HTTPS，不过没有中文文档，国内的使用相对来说比较少，所以在接入的时候可能会略花一点时间。</p>
<p>这是一个 python 库， 首先要安装 <code>virtualenv</code>，如果本地没装的话输入: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip install virtualenv</div></pre></td></tr></table></figure>
<p>安装好了以后，进入 <code>mitmproxy/venv3.5/bin</code> 文件夹输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">source</span> ./active</div></pre></td></tr></table></figure>
<p>这样就可以启用 virtualenv 环境了。</p>
<h2 id="Hook-脚本"><a href="#Hook-脚本" class="headerlink" title="Hook 脚本"></a>Hook 脚本</h2><p>这个库可以理解为命令行中可交互版本的 Charles，不过我并不打算用它的这个功能。因为我的需求主要是利用脚本来 Hook 请求， 所以我选择了 mitmdump 这个工具。使用它的时候可以指定脚本:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mitmdump <span class="_">-s</span> <span class="string">"xxx.py"</span></div></pre></td></tr></table></figure>
<p>脚本也很简单，我们可以重写 <code>requeest</code> 或者 <code>receive</code> 函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(flow)</span>:</span></div><div class="line">        flow.response.content = <span class="string">"&lt;p&gt;hello world&lt;/p&gt;"</span></div></pre></td></tr></table></figure>
<p>运行脚本以后，把手机的代理设为本机 ip 地址，端口号改为 8080，然后用手机浏览器打开 <a href="http://mitm.it/" target="_blank" rel="external">http://mitm.it/</a>，如果一切配置顺利，你会看到证书的安装界面。</p>
<p>安装好证书后，用手机访问任何一个网站(包括 HTTPS)，你应该都会看到一个小小的 <code>hello world</code>，至此所有的配置就完成了。</p>
<h2 id="bug-修改"><a href="#bug-修改" class="headerlink" title="bug 修改"></a>bug 修改</h2><p>这个开源库有一个很严重的 bug，在解析 multipart 类型的数据时可能会发生。它使用了 <code>splitline</code> 方法来分割换行符，然而如果数据中有 <code>\n</code> 的话，就会因此丢失。很不幸的是，很多 protobuf 编码后的数据都有 <code>\n</code>，一旦丢失就会导致解析失败。</p>
<p>如果你不幸遇到了和我一样的坑，可以把相关代码改成我的版本:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> content.split(<span class="string">b"--"</span> + boundary):</div><div class="line">    parts = i.split(<span class="string">b'\r\n\r\n'</span>, <span class="number">2</span>)</div><div class="line">    <span class="keyword">if</span> len(parts) &gt; <span class="number">1</span> <span class="keyword">and</span> parts[<span class="number">0</span>][<span class="number">0</span>:<span class="number">2</span>] != <span class="string">b"--"</span>:</div><div class="line">        match = rx.search(parts[<span class="number">0</span>])</div><div class="line">        <span class="keyword">if</span> match:</div><div class="line">            key = match.group(<span class="number">1</span>)</div><div class="line">            value = parts[<span class="number">1</span>][<span class="number">0</span>:len(parts[<span class="number">1</span>])<span class="number">-2</span>] <span class="comment"># Remove last \r\n</span></div><div class="line">            r.append((key, value))</div></pre></td></tr></table></figure>
<h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>到了这一步，基本上已经成功实现支持 HTTPS 的代理服务器了。后续要处理的可能就是解析 protobuf，完善业务代码等等琐碎的事情，只要小心谨慎，基本上不会有问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久不写博客了，在元旦到来前水一篇文章，聊聊我在实现代理服务器的过程中遇到的一些坑，同时祝各位读者新年快乐。&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;长期以来，贴吧开
    
    </summary>
    
    
      <category term="python" scheme="http://fullstack.blog/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>该死的 XML in Android</title>
    <link href="http://fullstack.blog/2016/12/12/%E8%AF%A5%E6%AD%BB%E7%9A%84-XML-in-Android/"/>
    <id>http://fullstack.blog/2016/12/12/该死的-XML-in-Android/</id>
    <published>2016-12-12T10:19:15.000Z</published>
    <updated>2016-12-12T13:03:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽然大三曾经短暂的接触 Android，但都只是囫囵吞枣，仅仅停留在调用 API 和开源库完成效果的程度上。既然真的要开始搞 Android，还是有必要刨根问底一下的。</p>
<p>作为入门，最近开始看 Google 的 <a href="https://developer.android.com/training/index.html" target="_blank" rel="external">Android Training</a>。最简单的肯定是创建一个 Hello World 工程，不过在写 LinearLayout 的时候，我发现一个比较奇怪的问题：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span>&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>XML 文件中的前两行代码似乎很啰嗦，定义了两个 <code>xmlns</code> 和一长串没有意义的 URL。</p>
<p>实际上这里的 <code>xmlns</code> 指的是 XML 中的命名空间（namespace）概念。比如这里的 <code>android:layout_width</code> 属性，它就是 <code>android</code> 命名空间下的属性。如果没有命名空间的约束，整个 XML 中就不能出现重复的属性，事情就会很麻烦。</p>
<p>除了安卓默认提供的命名空间和控制 UI 样式的属性外，有时候，我们还可以自定义命名空间和属性，比如对于某个颜色来说，我希望它在普通模式和夜间模式下具有不同的样式，但对使用者完全透明（即对外只有一个颜色名）。</p>
<p>此时，就可以自定义一个 <code>app:bg_color</code>。要做到这一点，我们需要实现 <code>LayoutInflater.Factory</code> 接口并实现 <code>onCreateView</code> 方法。在将 XML 转化（inflate）为 View 的时候，实际上就是读取 XML 树中的各种属性和值，而 <code>onCreateView</code> 方法可以理解为这一过程的 Hook。</p>
<p>除此以外，我们也可以简单的添加几个常用的属性，<a href="http://stackoverflow.com/questions/2695646/declaring-a-custom-android-ui-element-using-xml" target="_blank" rel="external">这篇文章</a> 详细讲述了实现过程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然大三曾经短暂的接触 Android，但都只是囫囵吞枣，仅仅停留在调用 API 和开源库完成效果的程度上。既然真的要开始搞 Android，还是有必要刨根问底一下的。&lt;/p&gt;
&lt;p&gt;作为入门，最近开始看 Google 的 &lt;a href=&quot;https://develope
    
    </summary>
    
    
      <category term="Android" scheme="http://fullstack.blog/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Drawable 复用</title>
    <link href="http://fullstack.blog/2016/12/08/Drawable-%E5%A4%8D%E7%94%A8/"/>
    <id>http://fullstack.blog/2016/12/08/Drawable-复用/</id>
    <published>2016-12-08T10:16:35.000Z</published>
    <updated>2016-12-08T10:57:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="复用-Drawable"><a href="#复用-Drawable" class="headerlink" title="复用 Drawable"></a>复用 Drawable</h1><p><strong>Drawable</strong> 表示了一类通用的，可被绘制的资源。与View 的主要区别就在于，Drawable 并不会响应事件。</p>
<h2 id="Drawable-的复用机制"><a href="#Drawable-的复用机制" class="headerlink" title="Drawable 的复用机制"></a>Drawable 的复用机制</h2><p>Drawable 的使用非常方便，系统框架内部有 700 多种默认的 Drawable。当我们新建一个 button 时，实际上它的背景就是一个默认的 Drawable。</p>
<p>每个 Drawable 都有一个 <code>constant state</code>，这个 state 中保存了Drawable 所有的关键信息。比如对于 Button 来说，其中就保存了用于展示的 Bitmap。</p>
<p>由于 Drawable 非常常用，为了优化性能（其实主要就是节省内存），所有的 Drawable 都共享同一个 <code>constant state</code>。</p>
<h2 id="重用-state"><a href="#重用-state" class="headerlink" title="重用 state"></a>重用 state</h2><p>这种优化有时候也会导致一些问题，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Drawable star = context.getResources().getDrawable(R.drawable.star);</div><div class="line"><span class="keyword">if</span> (book.isFavorite()) &#123;</div><div class="line">  star.setAlpha(<span class="number">255</span>); <span class="comment">// opaque</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  star.setAlpha(<span class="number">70</span>); <span class="comment">// translucent</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设有多个 book 对象构成一个 <code>listview</code>，我们希望的效果是喜欢的图书，星星是亮的，否则是灭的。但如果使用上述代码就会发现，所有星星的颜色都是一样的。</p>
<p>这是因为 alpha 信息保存在 constant state 中，所有的星星都共享这个 state，对任何一个的修改都会影响其他所有的。</p>
<p>解决方案是使用 <code>mutate</code> 方法。这个方法会返回同一个 Drawable 对象，但是其中的 state 被复制了，这样对 state 的修改就互不干扰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Drawable star = context.getResources().getDrawable(R.drawable.star);</div><div class="line"><span class="keyword">if</span> (book.isFavorite()) &#123;</div><div class="line">  star.mutate().setAlpha(<span class="number">255</span>); <span class="comment">// opaque</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  star.mutate().setAlpha(<span class="number">70</span>); <span class="comment">// translucent</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="重用-bitmap"><a href="#重用-bitmap" class="headerlink" title="重用 bitmap"></a>重用 bitmap</h2><p>不过有时候仅仅复制 state 还不够，因为所有的 state 还会共享同一个 Bitmap，也就是说调用 <code>mutate()</code> 方法并不会复制 Bitmap。</p>
<p>假设我们有两个 TextView 需要设置圆角，我们可以首先创建一个 <code>GradientDrawable</code> 对象并设置圆角：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">GradientDrawable gd = <span class="keyword">new</span> GradientDrawable();</div><div class="line">gd.setColor(Color.parseColor(<span class="string">"#000000"</span>));</div><div class="line">gd.setCornerRadius(context.getResources().getDimension(R.dimen.ds4));</div><div class="line">gd.setStroke(<span class="number">1</span>, Color.parseColor(<span class="string">"#000000"</span>));</div></pre></td></tr></table></figure>
<p>接下来，任何需要设置圆角背景的 TextView 都可以调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">textview.setBackgroundDrawable(gd);</div></pre></td></tr></table></figure>
<p>然而由于 Drawable 对象的 Bitmap 会被复用，所以即使我们调用了 <code>mutate()</code> 方法，所有的 TextView 的圆角背景区域依然都会以最后一个 TextView 的大小为准。</p>
<p>在这种情况下，我们可以通过 <code>constant state</code> 创建一个新的 Drawable 对象，此时这两个完全不同的对象会使用不用的 Bitmap，也就避免了上述问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">textview.setBackgroundDrawable(gd.getConstantState().newDrawable());</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;复用-Drawable&quot;&gt;&lt;a href=&quot;#复用-Drawable&quot; class=&quot;headerlink&quot; title=&quot;复用 Drawable&quot;&gt;&lt;/a&gt;复用 Drawable&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Drawable&lt;/strong&gt; 表示了一类通用的
    
    </summary>
    
    
      <category term="Android" scheme="http://fullstack.blog/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>新的开始</title>
    <link href="http://fullstack.blog/2016/11/18/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
    <id>http://fullstack.blog/2016/11/18/新的开始/</id>
    <published>2016-11-18T10:53:53.000Z</published>
    <updated>2016-12-08T12:55:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>在学习了两年 iOS 以后，我决定开始横向拓展，也就是所谓的全栈工程师（不是全干工程师！），或者说，叫 T 型人才听上去更高端。作出这样的改变主要是由内在原因和外在原因共同导致的。</p>
<h1 id="内因"><a href="#内因" class="headerlink" title="内因"></a>内因</h1><p>首先，经过了两年的学习，不管是基础的 UI 控件，还是 <code>UITableView</code> 的各种调优，基本上都达到了掌握的程度。在准备面试和后来与同行交流的过程中，也对 ARC、Block、Rumtime、Runloop、GCD、Thread 等底层概念和源码有了一定的理解。</p>
<p>因此，我逐渐发现对于个人来说，如果再从事 UI 和 功能点的开发，个人的技术水平将很难有质的飞跃。当然，这也是因人而异，如果是对编译器、C/C++ 等底层知识感兴趣，完全可以深入挖掘，还有非常多值得学习的内容。</p>
<p>不过我本来就是对底层知识不感兴趣的人，我尤其反对面试时过度拿毫无用处的“底层知识”来为难面试者。我所理解的有用的底层知识，应该是指那些经常用到，但一般人说不清楚，而且一旦说不清楚就会影响编程的那些知识。</p>
<p>比如常见的 GCD 何时发生死锁，ARC 下的内存管理，Block 的实现原理、Runloop 与定时器等。这些底层知识如果不详细掌握，将会在实际开发中写出无法维护的代码，引入匪夷所思的 bug。</p>
<p>然而，计算机的发展趋势向来就是不断封装底层的实现细节。从早期的手写机器码，到后来的链接器处理重定位问题，再到 C 语言和现代的编程语言，无一不是屏蔽底层信息，从而提高开发者的效率。因此，过度的追求技术细节在我看来是一种浪费时间的行为，只有站在前人的肩膀上才能走的更远。</p>
<h1 id="外因"><a href="#外因" class="headerlink" title="外因"></a>外因</h1><p>自从三月份参加工作后，我陆陆续续接触了很多非 iOS 方面的知识。从调研 React Native、JSPatch 的实现原理，到学习 Python、Ruby、Shell 脚本语言，以及目前在做的 HTTP 代理、Android 开发，我见识到了很多新的技术和思想。我开始意识到，很多思想在不同平台都有，只不过是换了个名字和上下文。一个有能力、有经验、常思考的开发者可以非常容易的从一个平台转到一个类似的平台，靠的就是他对语言、业务的理解。</p>
<p>当然，快速入门别的语言和业务并不是我的目标，我也时刻提醒自己不要沦为全干工程师。了解多个语言、掌握多种技术的目的，并不是为了自己能同时干好几个工种，而是能够吸取各个平台的长处。</p>
<p>一方面，自己对技术的理解可以因此得到增强。比如说同样是哈希，客户端（Java 和 Objective-C）看重的是对象一致性，而不关心重哈希的性能。Java 作为一种服务端语言，提供了自动转红黑树的机制，提高了极端情况下的性能。而 Redis 中没有对象等同性的概念，所以它提供了统一的哈希函数，并实现了增量重哈希。而在分布式网站架构中，我们又使用一致性哈希的技术来处理哈希冲突。</p>
<p>可见，不同的场景下对于同一问题通常会作出取舍，但是多方面了解解决问题的思路有助于优化改善我们今后自己在处理其他问题时的设计方案，从而可以更加接近问题的本质并作出更好的决策。</p>
<p>另一方面，多种技术一旦合并起来，就能形成强大的战斗力。今年非常火的 JSPatch、RN、Weex 足以证明。</p>
<h1 id="企业"><a href="#企业" class="headerlink" title="企业"></a>企业</h1><p>说了这么多废话，归根结底还是希望自己的未来能够更光明（说得再简单暴力点就是工资高）。我相信绝大多数人工作的目的都是为了工资，那么就从企业的角度聊聊。</p>
<p>首先，企业雇人的终极目的也是唯一目的就是赚钱。只有为企业赚到更多的钱，才有可能拿到更高的工资。因此支付我们工资的，不是技术而是企业利润，我们仅仅是通过自己的技术为企业获得利润。从这一点上看，我们只要会写 UI 和功能，就可以拿工资了。</p>
<p>实际上，了解一定程度的底层知识可以避免 bug、提高开发效率。因为一旦发生 bug，或者开发效率低下，企业的收益必然受到严重影响。因此，适当的掌握底层技术可以获得更高的工资。</p>
<p>然而，如果一味地追求底层技术，就意味着相当多的知识难以在实际生产中用上，可选择的就业面也就越来越窄，其中相当一部分技术如果用来炫技还行，但对于利润的贡献其实并不大。</p>
<p>其次，企业其实非常需要优秀的技术管理者。一个既精通前端、又精通客户端的技术经理，在开发 Hybrid 应用时具有相当大的优势。同样的，既精通客户端，又精通服务端的技术经理可以在网络通信的过程中发挥自己的长<br>处。</p>
<p>更可怕的是， 如果不能站在对方的立场上思考问题，或者不了解对方的开发模式，就会浪费相当多的时间在沟通、交流上，一旦设计错误还会造成难以挽回的损失。</p>
<p>因此，无论技术如何变迁，掌握多项技能，能站在一定高度上综合的思考问题，拥有良好沟通、设计能力的技术管理者，一直会是公司最宝贵的人才。</p>
<h1 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h1><p>在这个博客里，我会写非常杂的内容，包括但不局限于 Python、Android、Java、HTTP、JavaScript ……。文章会分为两种类型，一种是对某个问题的简单总结，更新频率较高。另一种则是对某个话题深入全面的思考，更新频率<br>较低。</p>
<p>同时，作为一名 iOS 开发者，iOS 开发是我安身立命的本钱，因此<a href="https://bestswifter.com" target="_blank" rel="external">旧的博客</a> 将会持续维护下去，主要讨论 iOS、Objectie-C 和 Swift 技术。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在学习了两年 iOS 以后，我决定开始横向拓展，也就是所谓的全栈工程师（不是全干工程师！），或者说，叫 T 型人才听上去更高端。作出这样的改变主要是由内在原因和外在原因共同导致的。&lt;/p&gt;
&lt;h1 id=&quot;内因&quot;&gt;&lt;a href=&quot;#内因&quot; class=&quot;headerlin
    
    </summary>
    
    
  </entry>
  
</feed>
